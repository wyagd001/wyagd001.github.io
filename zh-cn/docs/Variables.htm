<!DOCTYPE HTML>
<html>
<head>
<title>变量和表达式 | AutoHotkey v1</title>
<meta name="description" content="Learn details about variables, expressions, operators, built-in variables and capacity and memory of variables." />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
</head>

<body>
<h1>变量和表达式</h1>

<h2 id="toc">目录</h2>
<ul>
  <li><a href="#Intro">变量</a></li>
  <li><a href="#Expressions">表达式</a></li>
  <li><a href="#Operators">表达式中的运算符</a></li>
  <li><a href="#BuiltIn">内置变量</a></li>
  <li><a href="#cap">变量的容量和占用内存</a></li>
</ul>
<span id="Variables"></span><h2 id="Intro">变量</h2>
<p>有关一般说明和变量如何工作的详细信息, 请参阅<a href="Concepts.htm#variables">变量</a>.</p>
<p id="assigning"><strong>给变量赋值:</strong> 要将字符串或数字存储在变量中, 有两种方法: <a href="Language.htm#legacy-syntax">传统方式</a>和<a href="Language.htm#expressions">表达式</a>. 传统方法使用<a href="lib/SetEnv.htm">等号运算符(=)</a> 来指定<a href="Language.htm#unquoted-text"><strong>不加引号的</strong>原义字符串</a>或用百分号括起来的变量. 例如:</p>
<pre>MyNumber = 123
MyString = This is a literal string.
CopyOfVar = %Var%  <em>; 和 = 运算符一起使用时, 需要使用百分号来获取变量的内容.</em></pre>
<p>与之相比, 表达式方法使用<a href="lib/SetExpression.htm">冒号等号运算符(:=)</a> 来保存数字, <a href="Language.htm#strings"><strong>加引号的</strong>字符串</a>和其他类型的<a href="Language.htm#expressions">表达式</a>. 以下示例在功能上与前面的例子相同:</p>
<pre>MyNumber := 123
MyString := "This is a literal string."
CopyOfVar := Var  <em>; 和前面段落中与其作用相同的语句不同, 百分号不和 := 运算符一起使用.</em></pre>
<p>后一种方法由于其更清晰并且与其他许多语言几乎一致的<a href="Language.htm#expressions">表达式语法</a>成为大多数人的首选方法.</p>
<p>从上面的例子中您可能已经想到了有两种方法来清除变量的内容(即让变量为空):</p>
<pre>MyVar =
MyVar := ""</pre>
<p>上面的这对空引号只能和冒号等号运算符(:=) 一起使用, 因为和等号运算符(=) 一起使用时, 则会在变量中保存两个原义的引号字符.</p>
<p id="retrieving"><strong>获取变量的内容:</strong> 如同赋值有两种方法, 获取变量的内容也有两种方法: <a href="Language.htm#legacy-syntax">传统方法</a>和<a href="Language.htm#variables">表达式方法</a>. 传统方法需要将变量名包围在百分号中来获取变量的内容. 例如:</p>
<pre><a href="lib/MsgBox.htm">MsgBox</a> The value in the variable named Var is %Var%.
CopyOfVar = %Var%</pre>
<p>与之相比, 表达式方法省去了变量名两边的百分号, 但<a href="Language.htm#strings">原义的字符串</a>必须包围在双引号中. 所以, 下面的表达式作用等同于上面的例子:</p>
<pre>MsgBox % "The value in the variable named Var is " . Var . "."  <em>; 使用句点连接(join 拼接) 两个字符串.</em>
CopyOfVar := Var</pre>
<p>在上面的 MsgBox 这行, 通过使用<a href="Language.htm#-expression">百分号和空格</a>把参数从传统模式改变为表达式模式. 因为所有的命令默认情况下使用传统模式(除了另外注明的那些), 所以这是必须的.</p>
<p><strong>变量的比较:</strong> 请阅读下面表达式部分中关于不同类型变量比较的重要提示, 尤其是关于何时使用小括号的内容.</p>

<h2 id="Expressions">表达式</h2>
<p class="note">有关结构化概述和进一步说明, 请参阅<a href="Language.htm#expressions">表达式</a>.</p>
<p>表达式用来对一系列变量, 原义字符串和/或原义数字执行一个或多个操作.</p>
<p>表达式中的变量名称不用包围在百分号中(<a href="misc/Arrays.htm#pseudo">伪数组</a>和其他的<a href="#ref">双重引用</a>除外). 所以, 为了与变量区别, 原义的字符串必须用双引号包围. 例如:</p>
<pre>if (CurrentSetting &gt; 100 or FoundColor != "Blue")
    MsgBox The setting is too high or the wrong color is present.</pre>
<p>在上面的例子中, 因为 "Blue" 是原义字符串, 所以包围在双引号中. 要在原义字符串中包含 <em>真实的</em> 引号字符, 请指定两个连续的引号, 如同此例中的两次演示: <code>"她说, <span class="red">""</span>一天一个苹果.<span class="red">""</span>"</code>.</p>
<p class="warning"><strong>注意:</strong> 有几种类型的 <a href="Language.htm#if-statement">If 语句</a>看起来像表达式, 但实际上不是.</p>
<p><strong>空字符串:</strong> 要在表达式中使用空字符串, 请指定一对空引号. 例如, 当 <em>MyVar</em> 非空时语句 <code>if (MyVar != "")</code> 的结果为真. 然而, 在<a href="lib/IfEqual.htm">遗留 if 语句</a>中, 一对空引号会被视为原义的字符串. 例如, 当 <em>MyVar</em> 仅包含一对真实的引号时语句 <code>if MyVar = ""</code> 结果为真. 因此, 要使用遗留的 if 语句判断变量是否为空, 则需要让 = 或 != 的右侧为空, 例如: <code>if Var =</code>.</p>
<p>相关提示, 任何无效的表达式例如 <code>(x +* 3)</code> 会产生空字符串.</p>
<p><strong>保存表达式的结果:</strong> 要把结果赋值给变量, 请使用<a href="lib/SetExpression.htm">冒号等号运算符(:=)</a>. 例如:</p>
<pre>NetPrice := Price * (1 - Discount/100)</pre>
<p id="Boolean"><strong>布尔值:</strong> 要计算表达式结果为真还是假时(例如 IF 语句), 表达式结果为空或零被视为假, 而其他所有结果都视为真. 例如, 仅当 ItemCount 为空或 0 时 <code>if ItemCount</code> 的结果才为假. 类似地, 表达式 <code>if not ItemCount</code> 将产生相反的结果.</p>
<p>像 <b>NOT</b>/<b>AND</b>/<b>OR</b>/<b>&gt;</b>/<b>=</b>/<b>&lt;</b> 这些运算符的运算会自动产生真值或假值的结果: 真值时结果为 1 而假值时为 0. 例如, 在下面的表达式中, 如果有一个条件为真则变量 <em>Done</em> 被赋值为 1:</p>
<pre>Done := A_Index &gt; 5 or FoundIt</pre>
<p>如上面提示的那样, 简单地置空变量或为其赋值为 0 可以让它为假值. 利用这种特性, 可以使用简写语句 <code>if Done</code> 来检查变量 Done 是真还是假.</p>
<p><span id="True"></span><span id="False"></span>单词 <em>true</em> 和 <em>false</em> 是值分别为 1 和 0 的内置变量. 使用它们可以增加脚本的可读性, 例如:</p>
<pre>CaseSensitive := false
ContinueSearch := true</pre>
<p><strong>整数和浮点数:</strong> 在表达式中, 含有小数点的数字被视为浮点数; 否则视为整数. 对于大多数运算符(例如加法和乘法), 只要其中的一个输入是浮点数, 那么结果也将是浮点数.</p>
<p>不论在表达式中还是在表达式外的其他地方, 整数都可以表示成十六进制或十进制. 十六进制数必须以前缀 0x 开头. 例如, <code>Sleep 0xFF</code> 等同于 <code>Sleep 255</code>. <span class="ver">[v1.0.46.11+]</span>: 可以识别用科学计数法表示的浮点数; 但只有在它们含有小数点时才行(例如 <code>1<strong>.</strong>0e4</code> 和 <code>-2<strong>.</strong>1E-4</code>).</p>
<p id="percent-space"><strong>强制使用表达式:</strong> 通过在表达式前加上百分号和空格或 tab, 能把表达式用在不直接支持表达式的参数中(除了 OutputVar 参数). 在 <span class="ver">[v1.1.21+]</span> 中, 这个前缀可以在所有命令的 InputVar 参数中使用, 除了遗留的 IF 命令(使用 <a href="lib/IfExpression.htm">If (表达式)</a> 代替). 这种技巧常用来访问<a href="misc/Arrays.htm">数组</a>. 例如:</p>
<pre><a href="lib/FileAppend.htm">FileAppend</a>, % MyArray%i%, My File.txt
<a href="lib/FileAppend.htm">FileAppend</a>, % MyPseudoArray%i%, My File.txt
<a href="lib/MsgBox.htm">MsgBox</a> % "The variable MyVar contains " . MyVar . "."
<a href="lib/Loop.htm">Loop</a> % Iterations + 1
<a href="lib/WinSet.htm">WinSet</a>, Transparent, % X + 100
<a href="lib/Control.htm">Control</a>, Choose, % CurrentSelection - 1</pre>

<h2 id="Operators">表达式中的运算符</h2>
<p class="note">有关运算符的一般信息, 请参阅<a href="Language.htm#operators">运算符</a>.</p>
<p>除了下面注明的情况, 其他时候在数学运算中包含的任何空值(空字符串) 或非数字值包括算术运算符中的都 <strong>不会</strong> 被假定为零. 而是被视为错误, 这将导致那部分表达式的计算结果为空字符串. 例如, 如果变量 X 为空, 那么表达式 X + 1 会返回空值而不是 1.</p>
<p>由于历史原因, <em>引号包围</em> 形如 <code>"123"</code> 的数字字符串直接用于表达式时, 总是视为做非零的(不过如果是用变量来保存, 或者是函数的返回值则不是这样). 这种非零的属性还会被<a href="#concat">连接符</a>改变, 所以形如 <code>"0x" n</code> 的表达式同样会产生一个非零值(即使 n 包含有效的十六进制值, 拼接后也会被视为非零的字符串值). 如果要避开这个问题, 可以把它保存到变量中或者用函数处理一次, 比如用 <a href="Functions.htm#Round">Round()</a> 处理后的返回值总是纯数字类型. 实际运用中, 脚本应该避免用双引号包围原义的数字, 因为将来的版本中可能会改变.<br>(译者注: 即 <strong>尽量避免</strong> 类似: <code>if ("1" < 2)</code> 这种形式书写表达式, 虽然目前这样做是合法的, 除非你真的是把这个数字当做文本来处理).</p>

<h3 id="operators">表达式运算符(按优先级降序排列)</h3>
<table class="info">
  <tr>
    <th class="center">运算符</th>
    <th abbr="Descr">描述</th>
  </tr>
  <tr id="ref">
    <td class="center bold">%Var%</td>
    <td><p>如果表达式中的变量包围在百分号中(例如 %Var%), 不管此变量 <u>包含</u> 什么内容都会被假定为另一个变量的名称或部分名称(如果不存在这样的变量, 那么 %Var% 会被解析为空字符串). 这种方法常用来引用<a href="misc/Arrays.htm#pseudo">伪数组</a>元素, 例如:</p>
      <pre>Var := MyArray%A_Index% + 100</pre>
      <p>为了向后兼容, 注明了 "可以使用表达式" 的命令参数把百分号中的孤立名称(例如 %Var%, 但不是 Array%i%) 当作其两边的百分号不存在一样. 通过把引用包围在括号中可以避免这种情况; 例如 <code>Sleep (%Var%)</code>.</p>
      <p><span class="ver">[AHK_L 52+]</span>: 除了普通变量, %Var% 还可以解析为<a href="Concepts.htm#environment-variables">环境变量</a>, 剪贴板或任何的<a href="#BuiltIn">保留/只读的变量</a>. 在修订号 52 之前, 在这些情况中 %Var% 会被当成空字符串.</p></td>
  </tr>
  <tr>
    <td class="center bold">x.y</td>
    <td><span class="ver">[AHK_L 31+]</span>: <strong>对象访问</strong>. 从对象 <i>x</i> 中读取或设置值或调用其方法, 此处 <i>y</i> 是个原义值. 请参阅<a href="Objects.htm#Usage_Objects">对象语法</a>.</td>
  </tr>
  <tr id="new">
    <td class="center bold">new</td>
    <td><span class="ver">[v1.1.00+]</span>: 基于其他对象创建新对象. 例如, <code>x := new y</code> 通常等价于 <code>x := {base: y}</code>.<code>new</code> 后应该跟着变量或 <code>GlobalClass.NestedClass</code> 形式的简单类名, 还可以像 <code>x := new y(z)</code> 那样加上可选参数(其中 <code>y</code> 是变量而非函数名). 更多细节请参阅<a href="Objects.htm#Custom_Objects">自定义对象</a>.</td>
  </tr>
  <tr id="IncDec">
    <td class="center bold">++<br>
    --</td>
    <td><strong>前置和后置的自增/自减</strong>. 从变量中增加或减去 1(但在 1.0.46 之前的版本中, 这些只能在一行上单独使用; 此行中不存在其他运算符). 运算符可以放在变量名的前面或后面. 如果放在变量名的 <em>前面</em>, 则立即执行自增/减运算并把结果用于下一运算. 例如, <code>Var := ++X</code> 让 X 自增后才把它的值赋给 <em>Var</em>. 相反地, 如果运算符放在变量名的 <em>后面</em>, 则在下一运算使用该变量 <em>之后</em> 才对其进行自增/减运算. 例如, <code>Var := X++</code> 把 X 的当前值赋给 <em>Var</em> 后才进行自增. 由于向后兼容性, 仅当空变量在一行中单独使用时, 运算符 ++ 和 -- 才把它们视为零; 例如, <code>y:=1, ++x</code> 和 <code>MsgBox % ++x</code> 当 x 为空时结果都为空. 该运算符用下面的例子来说明,<pre>
x=1
y=1
var1:=++x  ; 结果为 var1=2, x=2
var2:=y++  ; 结果为 var2=1, y=2
++z        ; 空变量单独使用
msgbox % z ; 结果为 z=1
</pre></td>
  </tr>
  <tr id="pow">
    <td class="center bold">**</td>
    <td>
      <p><strong>幂</strong>. 示例用法: <code>Base**Exponent</code>. <em>底数</em> 和 <em>指数</em> 都可以为小数. 如果 <em>指数</em> 为负数, 即使 <em>底数</em> 和 <em>指数</em> 都为整数, 结果也会被格式化为浮点数. 因为 ** 的优先级高于一元负号, 所以 <code>-2**2</code> 的计算过程和 <code>-(2**2)</code> 一样且得到结果 -4. 因此, 要让负号的优先级高于幂运算, 需要把它们包围在括号中, 例如 <code>(-2)**2</code>.</p>
      <p class="note"><strong>注意:</strong> 不支持 <em>底数</em> 为负数且 <em>指数</em> 为小数的情况, 例如 <code>(-2)**0.5</code>; 它会产生空字符串. 但 <code>(-2)**2</code> 和 <code>(-2)**2.0</code> 都是支持的. 该运算符用下面的例子来说明:<pre>
msgbox % 2**-2     ; 结果为 0.250000
msgbox % 2**(-2)   ; 结果为 0.250000
msgbox % -2**2     ; 结果为 -4
msgbox % -(2**2)   ; 结果为 -4
msgbox % (-2)**2   ; 结果为 4
msgbox % (-2)**2.0 ; 结果为 4.000000
msgbox % (-2)**0.5 ; 结果为空
</pre></p>
      <p class="warning"><strong>注意:</strong> 与数学上的对应项不同, ** 在 AutoHotkey v1 中是左结合的. 例如, <code>x ** y ** z</code> 计算为 <code>(x ** y) ** z</code>.</p>
    </td>
  </tr>
  <tr id="unary">
    <td class="center bold">-<br>
	!<br>
	~<br>
	&amp; *</td>
    <td><p><strong>一元负号(-):</strong> 尽管它和减运算符使用相同的符号, 但一元负号仅应用于单项或子表达式, 如此例中的两次演示: <code><strong>-</strong>(3 / <strong>-</strong>x)</code>. 相关提示, 表达式中的任何一元正号(+) 都会被忽略.</p>
      <p><strong>逻辑非(!):</strong> 如果运算数为空或 0, 那么逻辑非的结果为 1, 这表示 "真". 否则, 结果为 0(假). 例如: <code>!x or !(y and z)</code>. 注意: 单词 NOT 和 <strong>!</strong> 含义相同, 但 <strong>!</strong> 优先级更高. <span class="ver">[v1.0.46+]</span>: 允许使用连续的一元运算符, 例如 <code><strong>!!</strong>Var</code>, 因为它们是按从右到左的顺序计算.</p>
      <p><strong>按位非(~):</strong> 此运算符对运算数按位取反. 如果运算数为浮点数, 则在计算前把它截取成整数. 如果运算数介于 0 和 4294967295(0xffffffff) 之间, 那么它会被视为 <u>无符号的</u> 32 位值. 否则, 它被视为 <u>有符号的</u> 64 位值. 例如, <code>~0xf0f</code> 计算结果为 0xfffff0f0(4294963440).</p>
      <p id="amp"><strong>取址(&amp;):</strong> <code>&amp;MyVar</code> 获取 <em>MyVar</em> 的内容的内存地址, 此地址一般和 <a href="lib/DllCall.htm#struct">DllCall 结构</a>一起使用. 同时 <code>&amp;MyVar</code> 也禁用了此变量中的二进制数的缓存, 如果它经常用于数学或数值比较, 那么这会拖慢其性能. 每当变量的地址改变时会重新启用它的缓存(例如使用 <a href="lib/VarSetCapacity.htm">VarSetCapacity()</a>).</p>
      <p><strong>解除引用(*):</strong> <code>*Expression</code> 假定 <code>Expression</code> 解析为数字的内存地址; 它会获取在一个介于 0 和 255 之间的数字表示的内存地址中一个字节的内容(地址为 0 时获取的结果也总是 0; 但应该避免使用其他任何无效地址, 因为它可能会让脚本崩溃). 然而, 使用 <a href="lib/NumGet.htm">NumGet()</a> 获取二进制数通常会更好.</p></td>
  </tr>
  <tr id="MulDiv">
    <td class="center bold">*<br>
	/<br>
	//
    </td>
    <td><p><strong>乘(*):</strong> 如果两个输入都为整数, 则结果为整数; 否则结果为浮点数.</p>
      <p id="divide"><strong>真除(/):</strong> 与 <a href="lib/EnvDiv.htm">EnvDiv</a> 不同, 即使两个输入都是整数, 真除的结果也为浮点数. 例如, <code>3/2</code> 结果为 1.5 而不是 1, 而 <code>4/2</code> 结果为 2.0 而不是 2.</p>
      <p id="FloorDivide"><strong>向下舍除(//):</strong> 如果两个输入都是整数, 那么双斜杠运算符使用高效的整数除法. 例如, <code>5//3</code> 结果为 1 而 <code>5//-3</code> 结果为 -1. 如果任何一个输入为浮点数, 则执行浮点除法并把结果往下取整到最近的整数. 例如, <code>5//3.0</code> 结果为 1.0 而 <code>5.0//-3</code> 结果为 -2.0. 尽管浮点除法的结果为整数, 但它被保存为浮点格式, 以便其他使用者能使用浮点格式. 关于求模运算, 请参阅 <a href="lib/Math.htm#Mod">Mod()</a>.</p>
    <p><a href="#AssignOp">*= 和 /= 运算符</a>是用变量的值乘以或除以另一个值的一种简写形式. 例如, <code>Var*=2</code> 和 <code>Var:=Var*2</code> 会得到相同的结果(不过前者执行的更好).</p>
    <p>除数为零时结果为空(空字符串).</p></td>
  </tr>
  <tr id="AddSub">
    <td class="center bold">+<br>
    -</td>
    <td><p><strong>加(+)</strong> 和 <strong>减(-)</strong>. 相关提示, <a href="#AssignOp"><strong>+=</strong> 和 <strong>-=</strong></a> 运算符</a>是从变量中增加或减少值的一种简写形式. 例如, <code>Var+=2</code> 和 <code>Var:=Var+2</code> 会得到相同的结果(不过前者执行的更好). 同样地, 使用 <a href="#IncDec">Var++, Var--, ++Var 或 --Var</a> 可以让变量增加或减小 1.</p>
    </td>
  </tr>
  <tr id="bitshift">
    <td class="center bold">&lt;&lt;<br>
    &gt;&gt;<br>
    &gt;&gt;&gt;</td>
    <td>
      <p><strong>按位左移(&lt;&lt;)</strong>. 用法示例: <code>Value1 &lt;&lt; Value2</code>. 这等同于将 <em>Value1</em> 乘以 "2 的 <em>Value2</em> 次幂".</p>
      <p><strong>算术位右移(&gt;&gt;)</strong>. 用法示例: <code>Value1 &gt;&gt; Value2</code>. 这等同于将 <em>Value1</em> 除以 "2 的 <em>Value2</em> 次幂" 并把结果舍入到数轴上向左取整到最近的整数; 例如, <code>-3&gt;&gt;1</code> 结果为 -2.</p>
      <p><strong>逻辑位右移(&gt;&gt;&gt;)</strong> <span class="ver">[v1.1.35+]</span>. 用法示例: <code>Value1 &gt;&gt;&gt; Value2</code>. 与算术位右移不同, 这不会保留数字的符号. 例如, -1 与无符号 64 位整数 0xffffffffffffffff 具有相同的位表示, 因此 <code>-1 &gt;&gt;&gt; 1</code> 就是 0x7fffffffffffffff.</p>
      <p>对于这三个操作符, 在计算之前, 任何浮点输入都被截断为整数. 如果 <em>Value2</em> 小于 0 或大于 63, 则结果未定义.</p>
      <p class="note"><strong>译者注:</strong> 由于左移操作的运算速度比乘法的运算速度高很多, 因此在处理数据的乘法运算的时, 采用位移运算可以获得较快的速度(对 2 的乘法运算转换为位移运算, 可提高程序的运行效率).<br>实例过程演示: 例 5 &lt;&lt; 2(左移 2 位, 空出的位置上填 0, 最高位溢出则舍弃), 0000 0101(十进制 5) → 0001 0100(十进制 20). 右移与之相反, 对应除法(对 2 的整除运算).</p>
    </td>
  </tr>
  <tr id="bitwise">
    <td class="center bold">&amp;<br>
	  ^<br>
	  |
    </td>
    <td><strong>按位与(&amp;)</strong>, <strong>按位异或(^)</strong> 和 <strong>按位或(|)</strong>. 这三个运算符中, <strong>&amp;</strong> 优先级最高, 而 <strong>|</strong> 优先级最低. 任何浮点数在计算前会被截取成整数.<br>译者注: <strong>按位与(&amp;)</strong> 运算规则(二进制): 0&0=0; 0&1=0; 1&0=0; 1&1=1; 3&5=1(两位同时为 "1", 结果才为 "1", 否则为 0)
<br>
典型应用: 1. 清零特定位; 2. 取某数中指定位; 例子, 判断奇偶数 N&1; 只保留低八位 N&0xFF(255 以下的数字 & 0xFF 都得到原值).
<br><strong>按位异或(^)</strong> 运算规则(二进制): 0^0=0; 0^1=1; 1^0=1; 1^1=0; 3^5=6(如果两个相应位为 "异"(值不同), 则该位结果为 1, 否则为 0)
<br>
典型应用: 1. 使特定位翻转; 2. 保留原值 N^0;
<br>
<strong>按位或(|)</strong> 运算规则(二进制): 0|0=0; 0|1=1; 1|0=1; 1|1=1; 3|5=7(参加运算的两个对象只要有一个为 1, 其值为 1)
<br>
典型应用: 1. 设定一个数据指定位的值为 1. 例, 设数据的低八位都为 1, N|0xFF</td>
  </tr>
  <tr id="concat">
    <td class="center bold">.</td>
    <td><p><strong>连接</strong>. 句号(点) 两边都至少有一个空格或制表符, 用于将两个项目合并为单个字符串. 省略句点也可以达到相同的目的(除非表达式中有不明确的关系, 例如 <code>x <strong>-</strong>y</code>, 或在右边的项目含有前导的 ++ 或 -- 运算符). 省略句点时, 合并的两个项目间必须至少有一个空格或制表符.<br>
    <pre>Var := "The color is " <strong>.</strong> FoundColor  <em>; Explicit concat</em>
Var := "The color is " FoundColor    <em>; Auto-concat</em></pre>
    <p>还可以用来连接子表达式. 例如: <code>Var := "The net price is " <strong>.</strong> Price * (1 - Discount/100)</code>.</p>
    <p>以句点(或其他任何运算符) 开始的行会自动<a href="Scripts.htm#continuation">附加到</a>前一行的末尾.</p></td>
  </tr>
  <tr id="regex">
    <td class="center bold">~=</td>
    <td><span class="ver">[AHK_L 31+]</span>: 这是 <a href="lib/RegExMatch.htm">RegExMatch()</a> 的简写形式. 例如, <code>"abc123" ~= "\d"</code> 会设置 ErrorLevel 为 0 并返回数字 4(首个数字的位置). 在 <span class="ver">[v1.1.03]</span> 之前, 此运算符和 <em>等号 </em>(=) 或 (:=) 运算符优先级相同, 但并未在文档中说明.<br>译者注, ~= 的优先级低于 not(!), 也就是说会先取反再匹配. 下面是一个很深的坑, 请测试下面这个<span class="red">错误的例子</span>:<br>
    <pre>
str := "d"
if (! str ~= "abc"){        ; 必须用括号包围才能获得预期的效果 if ! (str ~= "abc")
  Msgbox 无法匹配字母 %str% ; 不会进入这里
} else {
  Msgbox 可以匹配字母 %str% ; 出乎意料的结果
}
    </pre>
再来测试, not(!) 与 := 相比优先级更低, 这是一个<span class="red">结果可以预料的例子</span>:
    <pre>
if (!str := "a"){            ; 效果同 if ! (str := "a")
  Msgbox 不正常: %str% 为 false
}else{
  Msgbox 正常: %str% 为 true ; 预期的效果
}
    </pre>
    </td>
  </tr>
  <tr id="compare">
    <td class="center bold">&gt;&nbsp;&nbsp;&nbsp;&lt;<br>
	  &gt;= &lt;=</td>
    <td>
      <p><strong>大于(&gt;)</strong>, <strong>小于(&lt;)</strong>, <strong>大于或等于(&gt;=)</strong> 和 <strong>小于或等于(&lt;=)</strong>. 如果两个输入都是<a href="Concepts.htm#numbers">数字</a>或<a href="Concepts.htm#numeric-strings">数字字符串</a>, 则将它们进行数字比较; 否则将按字母顺序对它们进行比较. 仅当 <a href="lib/StringCaseSense.htm">StringCaseSense</a> 打开时, 比较才区分大小写. 另请参阅: <a href="lib/Sort.htm">Sort</a></p>
      <p class="note"><strong>注意:</strong> 在 AutoHotkey v1 中, 直接在表达式中使用的带引号字符串(或与带引号的字符串连接的结果) 始终不被认为是数字.</p>
    </td>
  </tr>
  <tr id="equal">
    <td class="center bold">=<br>
    ==<br>
    &lt;&gt; !=<br>
    !==</td>
    <td>
      <p><strong>不区分大小写的等号(=)</strong>, <strong>区分大小写的等号(==)</strong> 和 <strong>不相等(&lt;&gt; 或 !=)</strong>. 如果两个输入都是<a href="Concepts.htm#numbers">数字</a>或<a href="Concepts.htm#numeric-strings">数字字符串</a>时, 则会对其进行数字比较; 否则按字母顺序进行比较. 运算符 <strong>!=</strong> 和 <strong>&lt;&gt;</strong> 在功能上是完全相同的. 运算符 <strong>==</strong> 的行为与 <strong>=</strong> 相同, 除了其中一个输入不是数字时, <strong>==</strong> 总是区分大小写, 而 <strong>=</strong> 总是不区分大小写(不区分大小写的方法取决于 <a href="lib/StringCaseSense.htm">StringCaseSense</a>). 与之相比, <strong>&lt;&gt;</strong> 和 <strong>!=</strong> 都遵循 <a href="lib/StringCaseSense.htm">StringCaseSense</a>.</p>
      <p><strong>区分大小写的不等号(!==)</strong> <span class="ver">[v1.1.35+]</span>. 行为与 <strong>==</strong> 相同, 只是结果是相反的.</p>
      <p class="note"><strong>注意:</strong> 在 AutoHotkey v1 中, 直接在表达式中使用的带引号字符串(或与带引号的字符串连接的结果) 始终不被认为是数字.</p>
      <p class="warning"><strong>过时的:</strong> 不推荐在新脚本中使用 &lt;&gt; 运算符. 请使用 != 运算符代替.</p>
    </td>
  </tr>
  <tr id="not">
    <td class="center bold">NOT</td>
    <td><strong>逻辑非</strong>. 除了优先级较低外, 其他的与 <strong>!</strong> 运算符相同. 例如, <code>not (x = 3 or y = 3)</code> 等同于 <code><strong>!</strong>(x = 3 or y = 3)</code>. </td>
  </tr>
  <tr id="and">
    <td class="center bold">AND<br>
	  &amp;&amp;</td>
    <td>这两个运算符都是 <strong>逻辑与</strong>. 例如: <code>x &gt; 3 and x &lt; 10</code>. 要提高性能, 则要应用<a href="Functions.htm#ShortCircuit">求值优化</a>. 此外, 以 AND/OR/&amp;&amp;/||(或其他任何运算符) 开始的行会自动<a href="Scripts.htm#continuation">附加到</a>前一行的末尾.</td>
  </tr>
  <tr id="or">
    <td class="center bold">OR<br>
	   ||</td>
    <td>这两个运算符都是 <strong>逻辑或</strong>. 例如: <code>x &lt;= 3 or x &gt;= 10</code>. 要提高性能, 则要应用<a href="Functions.htm#ShortCircuit">求值优化</a>.</td>
  </tr>
  <tr id="ternary">
    <td class="center bold">?:</td>
    <td><strong>三元运算符</strong> <span class="ver">[v1.0.46+]</span>. 此运算符是 <a href="lib/IfExpression.htm">if-else 语句</a>的简写形式. 它计算左侧的条件来决定两个分支中哪个作为最终结果. 例如, <code>var := x&gt;y ? 2 : 3</code>, 当 x 大于 y 时保存 2 到 <em>Var</em>; 否则保存 3. 为了提高性能, 只计算决定性的分支(请参阅<a href="Functions.htm#ShortCircuit">求值优化</a>). </td>
  </tr>
  <tr id="AssignOp">
    <td class="center bold">:=<br>
        +=<br>
        -=<br>
        *=<br>
        /=<br>
        //=<br>
        .=<br>
        |=<br>
        &amp;=<br>
        ^=<br>
        &gt;&gt;=<br>
        &lt;&lt;=<br>
        &gt;&gt;&gt;=
    </td>
    <td><p><strong>赋值</strong>. 对变量的内容进行运算, 然后把结果保存到同一个变量中(但在 1.0.46 之前的版本中, 这些运算符只能在一行中最左边使用, 且仅支持前五个运算符). 最简单的赋值运算符为<a href="lib/SetExpression.htm">冒号等号(:=)</a>, 它把表达式的结果保存到变量中. 关于其他运算符的功能说明, 请参阅这个表格中它们的相关条目. 例如, <code>Var //= 2</code> 执行<a href="#FloorDivide">向下舍除</a>, 把 <em>Var</em> 除以 2, 然后把结果保存回 <em>Var</em>. 同样地, <code>Var <strong>.=</strong> "abc"</code> 为 <code>Var := Var <strong>.</strong> "abc"</code> 的一种简写形式. </p>
      <p>与其他大多数运算符不同, 赋值运算是从右往左执行的. 因此, <code>Var1 := Var2 := 0</code> 这个语句中首先把 0 赋值给 <em>Var2</em>, 然后把 <em>Var2</em> 赋值给 <em>Var1</em>. </p>
    <p>如果使用赋值运算的结果作为其他某些运算符的输入, 那么输入的值是变量自身. 例如, 如果变量 <em>Var</em> 新增值后大于 50, 那么表达式 <code>(Var+=2) &gt; 50</code> 结果为真. 这样还允许赋值被作为 <a href="Functions.htm#ByRef">ByRef</a> 传递或获取它的<a href="#amp">地址</a>, 例如: <code>&amp;(x:="abc")</code>. </p>
    <p>需要避免语法错误或提供更直观的操作时, 会自动提升赋值运算符的优先级. 例如: <code>not x:=y</code> 等价于 <code>not (x:=y)</code>. 另外, <code class="no-highlight">x==y &amp;&amp; z:=1</code> 等同于 <code class="no-highlight">x==y &amp;&amp; (z:=1)</code>, 这是当 x 不等于 y 时的<a href="Functions.htm#ShortCircuit">短路计算</a>. 同样地, <code>++Var := X</code> 等价于 <code>++(Var := X)</code>; 而 <code>Z&gt;0 ? X:=2 : Y:=2</code> 等价于 <code>Z&gt;0 ? (X:=2) : (Y:=2)</code>.</p>
    <p><strong>&gt;&gt;&gt;=</strong> 需要 <span class="ver">[v1.1.35+]</span>.</p>
    <p>由向后兼容引起的已知限制(可能会在未来的版本中解决): 1) 当 <strong>/=</strong> 为表达式中最左边的运算符并且它不是<a href="#comma">多语句表达式</a>的一部分时, 而且输入都不是浮点数时, 它会执行<a href="#FloorDivide">向下舍除</a>(在其他所有情况中, <strong>/=</strong> 会执行<a href="#divide">真除</a>); 2) 仅当 <strong>+=</strong> 和 <strong>-=</strong> 为一行中最左边的运算符时, 它们才支持<a href="lib/EnvAdd.htm">日期/时间的计算</a>; 3) 运算符 <strong>+=</strong>, <strong>-=</strong> 和 <strong>*=</strong> 仅在空变量在一行单独使用时才把空变量视为零; 例如, <code>y:=1, x+=1</code> 和 <code>MsgBox % x-=3</code> 当 x 为空时都得到空的结果. </p></td>
  </tr>
  <tr id="comma">
    <td class="center bold">,</td>
    <td><p><strong>逗号(多语句)</strong> <span class="ver">[v1.0.46+]</span>. 逗号可以用来在单行中书写多个子表达式. 最常用于把多个赋值或函数调用聚集在一起. 例如: <code>x:=1<strong>,</strong> y+=2<strong>,</strong> ++index, MyFunc()</code>. 这样的语句按从左到右的顺序执行.
      <p class="note"><strong>注意:</strong> 以逗号(或其他任何运算符) 开始的行会自动<a href="Scripts.htm#continuation">附加到</a>前一行的末尾. 另请参阅: <a href="#CommaPerf">逗号的性能</a>.</p>
      <p><span class="ver">[v1.0.46.01+]</span>: 当逗号后紧跟着变量和等号时, 则这个等号会被自动当成<a href="lib/SetExpression.htm">赋值(:=)</a>. 例如, 后面所有的都是赋值: <code>x:=1, y=2, a=b=c</code>. 新脚本不应该依赖于这种行为, 因为它可能会改变. 该规则只适用于无格式的变量而不是<a href="#ref">双重引用</a>, 所以下面的内容只有一个赋值: <code>x:=1, %y%=2</code></p>
      <p id="CommaPerf"><span class="ver">[v1.0.48+]</span>: 使用逗号运算符常常比分开写单独的表达式速度更快, 尤其是把一个变量的值赋给另一个变量时(例如: <code>x:=y, a:=b</code>). 当越多的表达式联合成单个表达式时, 性能会持续得到提升; 例如, 把五个或十个简单的表达式联合成单个表达式速度可能提升 35&nbsp;%.</p>
    </td>
  </tr>
</table>
<p>下面列出的子表达式改变计算的优先级/顺序:</p>
<table class="info">
  <tr>
    <th class="center">表达式</th>
    <th abbr="Descr">描述</th>
  </tr>
<tr>
   <td class="center"><strong>(</strong><em>expression</em><strong>)</strong></td>
   <td>
      <p>括号中包含的任何子表达式. 例如, <code>(3 + 2) * 2</code> 强制 <code>3 + 2</code> 首先计算.</p>
      <p>对于多语句表达式, 将返回 <u>最开始的</u> 语句的结果. 例如, <code>(a := 1, b := 2, c := 3)</code> 返回 1.</p>
    </td>
</tr>
  <tr>
    <td class="center"><p><strong>Mod()<br>
	Round()<br>
	Abs()</strong></p></td>
    <td><strong>函数调用</strong>. 函数名后面必须紧跟一个左圆括号, 没有任何空格或制表符插入其间. 相关详细信息, 查看<a href="Functions.htm">函数</a>.<br>内置数学函数在<a href="lib/Math.htm">这里</a>.</td>
  </tr>
  <tr>
    <td class="center"><p><strong>%</strong><em>func</em><strong>%()</strong></p></td>
    <td>请参阅<a href="Functions.htm#DynCall">动态调用函数</a>.</td>
  </tr>
  <tr>
    <td class="center"><em>func</em><strong>.()</strong></td>
    <td><p><strong>弃用的:</strong> 不推荐使用这个语法. 而应该用 <code>%func%()</code>(对于函数名称和对象) 或 <code>func.Call()</code>(对于函数对象) 替代.</p>
    <p><span class="ver">[AHK_L 48+]</span>: 试图调用对象 <i>func</i> 的命名的空方法. 按照约定, 这是对象的 "默认" 方法. 如果 <i>func</i> 不是对象, 则调用<a href="Objects.htm#Default_Base_Object">默认基对象</a>.</p>
    <p><span class="ver">[v1.0.95+]</span>: 如果 <i>func</i> 为函数名, 则调用这个命名的函数.</p></td>
  </tr>
  <tr>
    <td class="center">Fn(<strong><em>Params</em>*</strong>)</td>
    <td><p><span class="ver">[AHK_L 60+]</span>: <a href="Functions.htm#VariadicCall">可变参数函数</a>. <em>Params(参数)</em> 是一个包含数组(对象) 的参数值.</p></td>
</tr>
<tr>
<td class="center"><strong>x[y]<br>[a, b, c]</strong></td>
<td>
<p><span class="ver">[AHK_L 31+]</span>: <strong>成员访问</strong>. 得到或设置值或是对象 <i>x</i> 调用方法, 当 <i>y</i> 是一个参数列表时(特别是数组引索或键) 或返回方法名的表达式.</p>
<p><span class="ver">[v1.0.97+]</span>: <strong>数组标识符</strong>. 如果左方括号前面没有值(或者一个产生值的子表达式), 它被理解为一个数组的开始. 例如, <code>[a, b, c]</code> 等同于 <code>Array(a, b, c)</code>(a, b 和 c 是变量).</p>
<p>查看<a href="Objects.htm#Usage_Simple_Arrays">数组语法</a>和<a href="Objects.htm#Usage_Objects">对象语法</a>以获取更多细节.</p>
</td>
  </tr>
  <tr>
    <td class="center"><strong>{a: b, c: d}</strong></td>
    <td><p><span class="ver">[v1.0.97+]</span>: <strong>对象标识符</strong>. 创建一个对象或关联数组. 例如, <code>x := {a: b}</code> 等同于 <code>x := Object("a", b)</code> 或者 <code>x := Object(), x.a := b</code>. 查看<a href="Objects.htm#Usage_Associative_Arrays">关联数组</a>以获取更多细节.</p></td>
  </tr>
</table>

<h2 id="BuiltIn">内置变量</h2>
<p>下面的变量被内置到程序中, 可以被任何脚本引用.</p>
<p class="note">有关一般信息, 请参阅<a href="Concepts.htm#built-in-variables">内置变量</a>.</p>
<h3 id="BuiltIn_TOC">目录</h3>
<ul>
  <li>特殊字符: <a href="#Space">A_Space</a>, <a href="#Tab">A_Tab</a></li>
  <li>脚本属性: <a href="#CommandLine">命令行参数</a>, <a href="#WorkingDir">A_WorkingDir</a>, <a href="#ScriptDir">A_ScriptDir</a>, <a href="#ScriptName">A_ScriptName</a>, <a href="#prop">(...更多...)</a></li>
  <li>日期和时间: <a href="#YYYY">A_YYYY</a>, <a href="#MM">A_MM</a>, <a href="#DD">A_DD</a>, <a href="#Hour">A_Hour</a>, <a href="#Min">A_Min</a>, <a href="#Sec">A_Sec</a>, <a href="#date">(...更多...)</a></li>
  <li>脚本设置: <a href="#IsSuspended">A_IsSuspended</a>, <a href="#BatchLines">A_BatchLines</a>,<a href="#ListLines">A_ListLines</a>, <a href="#TitleMatchMode">A_TitleMatchMode</a>, <a href="#settings">(...更多...)</a></li>
  <li>用户空闲时间: <a href="#TimeIdle">A_TimeIdle</a>, <a href="#TimeIdlePhysical">A_TimeIdlePhysical</a>, <a href="#TimeIdleKeyboard">A_TimeIdleKeyboard</a>, <a href="#TimeIdleMouse">A_TimeIdleMouse</a></li>
  <li>GUI 窗口和菜单栏: <a href="#Gui">A_Gui</a>, <a href="#GuiControl">A_GuiControl</a>, <a href="#GuiEvent">A_GuiEvent</a>, <a href="#EventInfo">A_EventInfo</a>, <a href="#gui">(...更多...)</a></li>
  <li>热键, 热字串和自定义菜单项: <a href="#ThisHotkey">A_ThisHotkey</a>, <a href="#EndChar">A_EndChar</a>, <a href="#ThisMenuItem">A_ThisMenuItem</a>, <a href="#h">(...更多...)</a></li>
  <li>操作系统和用户信息: <a href="#OSVersion">A_OSVersion</a>, <a href="#Screen">A_ScreenWidth</a>, <a href="#Screen">A_ScreenHeight</a>, <a href="#os">(...更多...)</a></li>
  <li>杂项: <a href="#Cursor">A_Cursor</a>, <a href="#Caret">A_CaretX</a>, <a href="#Caret">A_CaretY</a>, <a href="#Clipboard">Clipboard</a>, <a href="#ClipboardAll">ClipboardAll</a>, <a href="#ErrorLevel">ErrorLevel</a>, <a href="#misc">(...更多...)</a></li>
  <li>循环: <a href="#Index">A_Index</a>, <a href="#loop">(...更多...)</a></li>
</ul>
<h3 id="Special_Characters">特殊字符</h3>
<table class="info">
  <tr>
    <th abbr="Var">变量</th>
    <th abbr="Descr">描述</th>
  </tr>
  <tr id="Space">
    <td>A_Space</td>
    <td>此变量包含单个空格字符. 请参阅 <a href="lib/AutoTrim.htm">AutoTrim</a> 了解详情.</td>
  </tr>
  <tr id="Tab">
    <td>A_Tab</td>
    <td>此变量包含单个 tab 字符. 请参阅 <a href="lib/AutoTrim.htm">AutoTrim</a> 了解详情.</td>
  </tr>
</table>
<h3 id="prop">脚本属性</h3>
<table class="info">
  <tr>
    <th abbr="Var">变量</th>
    <th abbr="Descr">描述</th>
  </tr>
  <tr id="CommandLine">
    <td>1, 2, 3 等</td>
    <td>每当启动带命令行参数的脚本时, 会自动创建这些变量. 可以像普通变量一样修改和引用它们(例如: %1%), 但不能在<a href="#Expressions">表达式</a>中直接引用. 变量 %0% 包含了命令行参数的数目(如果没有则为 0). 需了解详情请参阅<a href="Scripts.htm#cmd">命令行参数</a>.</td>
  </tr>
  <tr id="Args">
    <td>A_Args<br><span class="ver">[v1.1.27+]</span></td>
    <td>一个包含命令行参数的<a href="Objects.htm#Usage_Simple_Arrays">数组</a>. 有关详细信息, 请参阅<a href="Scripts.htm#cmd">向脚本传递命令行参数</a>.</td>
  </tr>
  <tr id="WorkingDir">
    <td>A_WorkingDir</td>
    <td>脚本当前工作目录, 这是脚本访问文件的默认路径. 除非是根目录, 否则路径末尾不包含反斜杠. 两个示例: C:\ 和 C:\My Documents. 使用 <a href="lib/SetWorkingDir.htm">SetWorkingDir</a> 可以改变当前工作目录.</td>
  </tr>
  <tr id="InitialWorkingDir">
    <td>A_InitialWorkingDir<br><span class="ver">[v1.1.35+]</span></td>
    <td>脚本的初始工作目录, 这是由启动方式决定的. 例如, 如果它是通过快捷方式运行的 -- 比如在开始菜单上 -- 它的初始工作目录由快捷方式属性中的 "起始位置" 字段决定.</td>
  </tr>
  <tr id="ScriptDir">
    <td>A_ScriptDir</td>
    <td>当前脚本所在目录的绝对路径. 不包含最后的反斜杠(根目录同样如此).</td>
  </tr>
  <tr id="ScriptName">
    <td>A_ScriptName</td>
    <td>
    <p>当前脚本的文件名称, 不含路径, 例如 MyScript.ahk.</p>
    <p>如果脚本是<a href="Scripts.htm#ahk2exe">编译的</a>或<a href="Program.htm#embedded-scripts">嵌入的</a>, 这就是当前可执行文件的名称.</p>
  </tr>
  </td>
  <tr id="ScriptFullPath">
    <td>A_ScriptFullPath</td>
    <td>
        <p>当前脚本的完整路径, 例如 C:\My Documents\My Script.ahk</p>
        <p>如果脚本是<a href="Scripts.htm#ahk2exe">编译的</a>或<a href="Program.htm#embedded-scripts">嵌入的</a>, 这就是当前可执行文件的完整路径.</p>
    </td>
  </tr>
  <tr id="ScriptHwnd">
    <td>A_ScriptHwnd<br><span class="ver">[v1.1.01+]</span></td>
    <td>脚本的隐藏<a href="Program.htm#main-window">主窗口</a>的唯一 ID(HWND/句柄).</td>
  </tr>
  <tr id="LineNumber">
    <td>A_LineNumber</td>
    <td><p>当前脚本中正在执行的行所在的行号(或其 <a href="lib/_Include.htm">#Include 文件</a>的行号). 这个行号与 <a href="lib/ListLines.htm">ListLines</a> 显示的一致; 它可以用在报告错误的时候, 例如: <code>MsgBox Could not write to log file (line number %A_LineNumber%)</code>. </p>
    <p>由于<a href="Scripts.htm#ahk2exe">已编译脚本</a>已经把它所有的 <a href="lib/_Include.htm">#Include 文件</a>合并成一个大脚本, 所以它的行号可能与它在未编译模式运行时不一样.</p></td>
  </tr>
  <tr id="LineFile">
    <td>A_LineFile</td>
    <td>
      <p><a href="#LineNumber">A_LineNumber</a> 所属文件的完整路径和名称. 如果脚本是从外部文件加载的, 这等同于 <a href="#ScriptFullPath">A_ScriptFullPath</a>, 除非该行属于脚本的 <a href="lib/_Include.htm">#Include 文件</a>之一.</p>
      <p>如果脚本是基于一个 <a href="Scripts.htm#ahk2exe-base">.bin 文件</a><a href="Scripts.htm#ahk2exe">编译的</a>, 这就是当前可执行文件的完整路径和名称, 等同于 <a href="#ScriptFullPath">A_ScriptFullPath</a>.</p>
      <p><span class="ver">[v1.1.34+]</span>: 如果脚本是<a href="Program.htm#embedded-scripts">嵌入的</a>, A_LineFile 包含一个星号(*) 后面是资源名称; 例如 *#1</p>
    </td>
  </tr>
  <tr id="ThisFunc">
    <td>A_ThisFunc<br>
	<span class="ver">[v1.0.46.16+]</span></td>
    <td>当前正在执行的<a href="Functions.htm">自定义函数</a>的名称(没有则为空); 例如: MyFunction. 另请参阅: <a href="lib/IsFunc.htm">IsFunc()</a></td>
  </tr>
  <tr id="ThisLabel">
    <td>A_ThisLabel<br>
    <span class="ver">[v1.0.46.16+]</span></td>
    <td>当前正在执行的<a href="misc/Labels.htm">标签</a>(子程序) 的名称(没有则为空); 例如: MyLabel. 每当脚本执行 <a href="lib/Gosub.htm">Gosub</a>/<a href="lib/Return.htm">Return</a> 或 <a href="lib/Goto.htm">Goto</a> 时会更新此变量的值. 执行自动调用的标签时也会更新此变量的值, 例如<a href="lib/SetTimer.htm">计时器</a>, <a href="lib/Gui.htm#DefaultWin">GUI 线程</a>, <a href="lib/Menu.htm">菜单项</a>, <a href="Hotkeys.htm">热键</a>, <a href="Hotstrings.htm">热字串</a>, <a href="lib/OnClipboardChange.htm#label">OnClipboardChange 标签</a>和 <a href="lib/OnExit.htm#command">OnExit 标签</a>. 不过, 当执行从前面的语句 "进入" 一个标签时不会更新 A_ThisLabel 的值, 即此时它还是保持原来的值. 另请参阅: <a href="#ThisHotkey">A_ThisHotkey</a> 和 <a href="lib/IsLabel.htm">IsLabel()</a></td>
  </tr>
  <tr id="AhkVersion">
    <td>A_AhkVersion</td>
    <td>在 [1.0.22] 之前的版本, 此变量为空. 否则, 它包含了运行当前脚本的 AutoHotkey 主程序的版本号, 例如 1.0.22. 在<a href="Scripts.htm#ahk2exe">已编译脚本</a>中, 它包含了原来编译时使用的主程序的版本号. 格式化的版本号使得脚本可以使用 &gt; 或 &gt;= 来检查 A_AhkVersion 是否大于某个最小的版本号, 例如: <code>if A_AhkVersion &gt;= 1.0.25.07</code>. 另请参阅: <a href="lib/_Requires.htm">#Requires</a> 和 <a href="lib/VerCompare.htm">VerCompare()</a></td>
  </tr>
  <tr id="AhkPath">
    <td>A_AhkPath</td>
    <td>
      <p>对于非编译的或<a href="Program.htm#embedded-scripts">嵌入的</a>脚本: 实际运行当前脚本的 EXE 文件的完整路径和名称. 例如: C:\Program Files\AutoHotkey\AutoHotkey.exe</p>
      <p>对于基于 <a href="Scripts.htm#ahk2exe-base">.bin 文件</a>的<a href="Scripts.htm#ahk2exe">编译脚本</a>, 该值是通过从注册表中读取安装目录并附加 "\AutoHotkey.exe" 来确定的. 如果没有安装 AutoHotkey, 该值为空. 等同于下面的例子:</p>
      <pre>RegRead InstallDir, HKLM\SOFTWARE\AutoHotkey, InstallDir
AhkPath := ErrorLevel ? "" : InstallDir "\AutoHotkey.exe"</pre>
      <p><span class="ver">[v1.1.34+]</span>: 对于基于 .exe 文件的编译脚本, A_AhkPath 包含编译脚本的完整路径. 这可以与 <a href="Scripts.htm#SlashScript">/script</a> 结合使用来执行外部脚本. 如果要找到已安装的 AutoHotkey 副本, 请按上面所示读取注册表.</p>
     </td>
  </tr>
  <tr id="IsUnicode">
    <td>A_IsUnicode</td>
    <td>当字符串为 Unicode(16 位) 时值为 1, 字符串为 ANSI(8 位) 时为空字符串(这会被视为 <a href="#Boolean">false</a>). 字符串的格式取决于用来运行当前脚本的 AutoHotkey.exe, 如果为已编译脚本, 则取决于用来编译它的主程序.</p>
    <p>对于 <span class="ver">[v1.1.06]</span> 之前的 ANSI 可执行文件, A_IsUnicode 没有定义; 也就是说, 脚本可以给它赋值, 并且尝试读取它可能会触发 <a href="lib/_Warn.htm">UseUnsetGlobal 警告</a>. 在以后的版本中, 它始终是定义的并且是只读的.</p></td>
  </tr>
  <tr id="IsCompiled">
    <td>A_IsCompiled</td>
    <td>如果当前运行的脚本为<a href="Scripts.htm#ahk2exe">已编译的 EXE </a> 时, 此变量值为 1, 否则为空字符串(这会被视为 <a href="#Boolean">false</a>).</p>
    <p>对于 <span class="ver">[v1.1.06]</span> 之前的未编译脚本, A_IsCompiled 没有定义; 也就是说, 脚本可以给它赋值, 并且尝试读取它可能会触发 <a href="lib/_Warn.htm">UseUnsetGlobal 警告</a>. 在以后的版本中, 它始终是定义的并且是只读的.</p></td>
  </tr>
  <tr id="ExitReason">
    <td>A_ExitReason</td>
    <td>最近一次要求脚本终止的原因. 除非脚本含有 <a href="lib/OnExit.htm#command">OnExit</a> 子程序并且此子程序当前正在运行或被退出尝试至少调用过一次, 否则此变量为空. 请参阅 <a href="lib/OnExit.htm#command">OnExit</a> 了解详情.</td>
  </tr>
</table>
<h3 id="date">日期和时间</h3>
<table class="info">
  <tr>
    <th abbr="Var">变量</th>
    <th abbr="Descr">描述</th>
  </tr>
  <tr id="YYYY">
    <td>A_YYYY</td>
    <td>
    <p>4 位数表示的当前年份(例如 2004). 与 A_Year 含义相同.</p>
      <p class="note"><strong>注意:</strong> 要获取符合您区域设置和语言的格式化时间或日期, 请使用 <code><a href="lib/FormatTime.htm">FormatTime</a>, OutputVar</code>(时间和长日期) 或 <code><a href="lib/FormatTime.htm">FormatTime</a>, OutputVar,, LongDate</code>(获取长格式日期). </p>
    </td>
  </tr>
  <tr id="MM">
    <td>A_MM</td>
    <td>2 位数表示的当前月份(01-12). 与 A_Mon 含义相同.</td>
  </tr>
  <tr id="DD">
    <td>A_DD</td>
    <td>2 位数表示的当前月份的日期(01-31). 与 A_MDay 含义相同.</td>
  </tr>
  <tr id="MMMM">
    <td>A_MMMM</td>
    <td>使用当前用户语言表示的当前月份的全称, 例如 July</td>
  </tr>
  <tr id="MMM">
    <td>A_MMM</td>
    <td>使用当前用户语言表示的当前月份的简称, 例如 Jul</td>
  </tr>
  <tr id="DDDD">
    <td>A_DDDD</td>
    <td>使用当前用户语言表示的当前星期几的全称, 例如 Sunday</td>
  </tr>
  <tr id="DDD">
    <td>A_DDD</td>
    <td>使用当前用户语言表示的当前星期几的简称, 例如 Sun</td>
  </tr>
  <tr id="WDay">
    <td>A_WDay</td>
    <td>1 位数表示的当前星期经过的天数(1-7). 在所有区域设置中 1 都表示星期天.</td>
  </tr>
  <tr id="YDay">
    <td>A_YDay</td>
    <td>当前年份中经过的天数(1-366). 不会使用零对变量的值进行填充, 例如会获取到 9, 而不是 009. 要对变量的值进行零填充, 请使用: <code><a href="lib/FormatTime.htm">FormatTime</a>, OutputVar, , YDay0</code>. </td>
  </tr>
  <tr id="YWeek">
    <td>A_YWeek</td>
    <td>符合 ISO 8601 标准的当前的年份和周数(例如 200453). 要分离年份和周数, 请使用 <code>Year := <a href="lib/SubStr.htm">SubStr</a>(A_YWeek, 1, 4)</code> 和 <code>Week := <a href="lib/SubStr.htm">SubStr</a>(A_YWeek, -1)</code>. A_YWeek 的准确定义为: 如果含有 1 月 1 日的星期有四天以上在新年里, 则它被认为是新年的第一个星期. 否则, 它为前一年的最后一个星期, 而下一星期为新年的第一星期.</td>
  </tr>
  <tr id="Hour">
    <td>A_Hour</td>
    <td>在 24 小时制(例如, 17 表示 5pm) 中 2 位数表示的当前小时数(00-23). 要获取带 AM/PM 提示的 12 小时制的时间, 请参照此例: <code><a href="lib/FormatTime.htm">FormatTime</a>, OutputVar, , h:mm:ss tt</code></td>
  </tr>
  <tr id="Min">
    <td>A_Min</td>
    <td><p>2 位数表示的当前分钟数(00-59).</p></td>
  </tr>
  <tr id="Sec">
    <td>A_Sec</td>
    <td>2 位数表示的当前秒数(00-59).</td>
  </tr>
  <tr id="MSec">
    <td>A_MSec</td>
    <td>3 位数表示的当前毫秒数(000-999). 要移除前导零, 请参照此例: <code>Milliseconds := A_MSec + 0</code>. </td>
  </tr>
  <tr id="Now">
    <td>A_Now</td>
    <td>
    <p><a href="lib/FileSetTime.htm#YYYYMMDD">YYYYMMDDHH24MISS</a> 格式的当前本地时间.</p> 
      <p class="note"><strong>注意:</strong> 使用 <a href="lib/EnvAdd.htm">EnvAdd</a> 和 <a href="lib/EnvSub.htm">EnvSub</a> 可以对日期和时间进行计算. 此外, 使用 <a href="lib/FormatTime.htm">FormatTime</a> 可以根据您的区域设置或选项来格式化日期和/或时间.</p>
    </td>
  </tr>
  <tr id="NowUTC">
    <td>A_NowUTC</td>
    <td><a href="lib/FileSetTime.htm#YYYYMMDD">YYYYMMDDHH24MISS</a> 格式的当前的协调世界时(UTC). UTC 本质上和格林威治标准时间(GMT) 一致.</td>
  </tr>
  <tr id="TickCount">
    <td>A_TickCount</td>
    <td><p>计算机启动后经过的毫秒数, 最多为 49.7 天. 通过把 A_TickCount 保存到变量中, 经过一段时间后从最近的 A_TickCount 值中减去那个变量, 可以计算出所经过的时间. 例如:</p>
        <pre>StartTime := A_TickCount
Sleep, 1000
ElapsedTime := A_TickCount - StartTime
MsgBox, %ElapsedTime% milliseconds have elapsed.</pre>
<p>如果您需要比 A_TickCount 的 10&nbsp;ms 更高的精确度, 请使用 <a href="lib/DllCall.htm#QPC">QueryPerformanceCounter()</a>(高精度计时器).</p>
</td>
  </tr>
</table>
<h3 id="settings">脚本设置</h3>
<table class="info">
  <tr>
    <th abbr="Var">变量</th>
    <th abbr="Descr">描述</th>
  </tr>
  <tr id="IsSuspended">
    <td>A_IsSuspended</td>
    <td>当脚本<a href="lib/Suspend.htm">挂起时</a>值为 1, 否则为 0.</td>
  </tr>
  <tr id="IsPaused">
    <td>A_IsPaused<br>
	<span class="ver">[v1.0.48+]</span></td>
    <td>当紧随当前线程的<a href="misc/Threads.htm">线程</a>被<a href="lib/Pause.htm">暂停</a>时值为 1, 否则为 0.</td>
  </tr>
  <tr id="IsCritical">
    <td>A_IsCritical<br>
	<span class="ver">[v1.0.48+]</span></td>
    <td><a href="misc/Threads.htm">当前线程</a>的 <a href="lib/Critical.htm">Critical</a> 设置关闭时值为 0. 否则它包含大于零的整数, 即 Critical 使用的<a href="lib/Critical.htm#Interval">消息检查间隔</a>. 因为 <code>Critical 0</code> 关闭了当前线程的关键性, 所以 Critical 的当前状态可以这样来保存和恢复: <code>Old_IsCritical := A_IsCritical</code>, 后来执行 <code>Critical %Old_IsCritical%</code>. </td>
  </tr>
  <tr id="BatchLines">
    <td>A_BatchLines</td>
    <td>(同义于 A_NumBatchLines) 由 <a href="lib/SetBatchLines.htm">SetBatchLines</a> 设置的当前值. 例如: 200 或 10 ms(取决于格式).</td>
  </tr>
  <tr id="ListLines">
    <td>A_ListLines<br><span class="ver">[v1.1.28+]</span></td>
    <td><a href="lib/ListLines.htm">ListLines</a> 激活时值为 1, 否则为 0.</td>
  </tr>
  <tr id="TitleMatchMode">
    <td>A_TitleMatchMode</td>
    <td>由 <a href="lib/SetTitleMatchMode.htm">SetTitleMatchMode</a> 设置的当前模式(1, 2, 3 或 RegEx).</td>
  </tr>
  <tr id="TitleMatchModeSpeed">
    <td>A_TitleMatchModeSpeed</td>
    <td>由 <a href="lib/SetTitleMatchMode.htm">SetTitleMatchMode</a> 设置的当前匹配速度(Fast 或 Slow).</td>
  </tr>
  <tr id="DetectHiddenWindows">
    <td>A_DetectHiddenWindows</td>
    <td>由 <a href="lib/DetectHiddenWindows.htm">DetectHiddenWindows</a> 设置的当前模式(On 或 Off).</td>
  </tr>
  <tr id="DetectHiddenText">
    <td>A_DetectHiddenText</td>
    <td>由 <a href="lib/DetectHiddenText.htm">DetectHiddenText</a> 设置的当前模式(On 或 Off).</td>
  </tr>
  <tr id="AutoTrim">
    <td>A_AutoTrim</td>
    <td>由 <a href="lib/AutoTrim.htm">AutoTrim</a> 设置的当前模式(On 或 Off).</td>
  </tr>
  <tr id="StringCaseSense">
    <td>A_StringCaseSense</td>
    <td>由 <a href="lib/StringCaseSense.htm">StringCaseSense</a> 设置的当前模式(On, Off 或 Locale).</td>
  </tr>
  <tr id="FileEncoding">
    <td>A_FileEncoding</td>
    <td><span class="ver">[AHK_L 46+]</span>: 包含了多个命令使用的默认编码; 请参阅 <a href="lib/FileEncoding.htm">FileEncoding</a>.</td>
  </tr>
  <tr id="FormatInteger">
    <td>A_FormatInteger</td>
    <td>由 <a href="lib/SetFormat.htm">SetFormat</a> 设置的当前整数格式(H 或 D). <span class="ver">[AHK_L 42+]</span>: 此变量还可能为小写字母 h.</td>
  </tr>
  <tr id="FormatFloat">
    <td>A_FormatFloat</td>
    <td>由 <a href="lib/SetFormat.htm">SetFormat</a> 设置的当前浮点数格式.</td>
  </tr>
  <tr id="SendMode">
    <td>A_SendMode</td>
    <td><span class="ver">[v1.1.23+]</span>: 由 <a href="lib/SendMode.htm">SendMode</a> 设置的当前模式字符串(可能的值为: Event, Input, Play 或 InputThenPlay).</td>
  </tr>
  <tr id="SendLevel">
    <td>A_SendLevel</td>
    <td><span class="ver">[v1.1.23+]</span>: 当前 <a href="lib/SendLevel.htm">SendLevel</a> 的设置(可能的值为: 0 到 100 之间的整数, 包括 0 和 100).</td>
  </tr>
  <tr id="StoreCapsLockMode">
    <td>A_StoreCapsLockMode</td>
    <td><span class="ver">[v1.1.23+]</span>: 由 <a href="lib/SetStoreCapsLockMode.htm">SetStoreCapsLockMode</a> 设置的当前模式字符串(可能的值为: On 或 Off).</td>
  </tr>
  <tr id="KeyDelay">
    <td>A_KeyDelay<br>
    A_KeyDuration</td>
    <td>由 <a href="lib/SetKeyDelay.htm">SetKeyDelay</a> 设置的当前延迟(总是十进制数, 不是十六进制). A_KeyDuration 依赖 <span class="ver">[v1.1.23+]</span> .</td>
  </tr>
  <tr id="KeyDelayPlay">
    <td>A_KeyDelayPlay<br>
    A_KeyDurationPlay</td>
    <td>表示由 <a href="lib/SetKeyDelay.htm">SetKeyDelay</a> 设置 <a href="lib/Send.htm#SendPlayDetail">SendPlay</a> 模式的延迟或持续时间(总是十进制数, 不是十六进制). 依赖 <span class="ver">[v1.1.23+]</span>.</td>
  </tr>
  <tr id="WinDelay">
    <td>A_WinDelay</td>
    <td>由 <a href="lib/SetWinDelay.htm">SetWinDelay</a> 设置的当前延迟(总是十进制数, 不是十六进制).</td>
  </tr>
  <tr id="ControlDelay">
    <td>A_ControlDelay</td>
    <td>由 <a href="lib/SetControlDelay.htm">SetControlDelay</a> 设置的当前延迟(总是十进制数, 不是十六进制).</td>
  </tr>
  <tr id="MouseDelay">
    <td>A_MouseDelay<br>
    A_MouseDelayPlay</td>
    <td>由 <a href="lib/SetMouseDelay.htm">SetMouseDelay</a> 设置的当前延迟(总是十进制数, 不是十六进制). A_MouseDelay 表示传统的 SendEvent 模式, 而 A_MouseDelayPlay 则表示 <a href="lib/Send.htm#SendPlayDetail">SendPlay</a>. A_MouseDelayPlay 依赖 <span class="ver">[v1.1.23+]</span>.</td>
  </tr>
  <tr id="DefaultMouseSpeed">
    <td>A_DefaultMouseSpeed</td>
    <td>由 <a href="lib/SetDefaultMouseSpeed.htm">SetDefaultMouseSpeed</a> 设置的当前速度(总是十进制数, 不是十六进制).</td>
  </tr>
  <tr id="CoordMode">
    <td>A_CoordModeToolTip<br>
    A_CoordModePixel<br>
    A_CoordModeMouse<br>
    A_CoordModeCaret<br>
    A_CoordModeMenu</td>
    <td><span class="ver">[v1.1.23+]</span>: <a href="lib/CoordMode.htm">CoordMode</a> 的当前设置值的字符串. (可能的值为: Window, Client 或 Screen) </td>
  </tr>
  <tr id="RegView">
    <td>A_RegView</td>
    <td><span class="ver">[v1.1.08+]</span>: 由 <a href="lib/SetRegView.htm">SetRegView</a> 设置的当前注册表视图. </td>
  </tr>
  <tr id="IconHidden">
    <td>A_IconHidden</td>
    <td><a href="Program.htm#tray-icon">托盘图标</a>当前隐藏时值为 1, 否则为 0. 此图标可以使用 <a href="lib/_NoTrayIcon.htm">#NoTrayIcon</a> 或 <a href="lib/Menu.htm">Menu</a> 命令进行隐藏.</td>
  </tr>
  <tr id="IconTip">
    <td>A_IconTip</td>
    <td>如果使用 <code><a href="lib/Menu.htm">Menu</a>, Tray, Tip</code> 为<a href="Program.htm#tray-icon">托盘图标</a>指定了自定义的工具提示时, 变量的值为这个提示的文本, 否则为空. </td>
  </tr>
  <tr id="IconFile">
    <td>A_IconFile</td>
    <td>如果使用 <code><a href="lib/Menu.htm">Menu</a>, tray, icon</code> 指定了自定义的<a href="Program.htm#tray-icon">托盘图标</a>时, 变量的值为图标文件的完整路径和名称, 否则为空.</td>
  </tr>
  <tr id="IconNumber">
    <td>A_IconNumber</td>
    <td>当 A_IconFile 为空时此变量为空. 否则, 它的值为 A_IconFile 中的图标编号(通常为 1).</td>
  </tr>
</table>
<h3 id="User_Idle_Time">用户空闲时间</h3>
<table class="info">
  <tr>
    <th abbr="Var">变量</th>
    <th abbr="Descr">描述</th>
  </tr>
  <tr id="TimeIdle">
    <td>A_TimeIdle</td>
    <td>
    <p>从系统最后一次接收到键盘, 鼠标或其他输入后所经过的毫秒数. 这可以用来判断用户是否离开. 用户的物理输入和由 <strong>任何</strong> 程序或脚本生成的模拟输入(例如 <a href="lib/Send.htm">Send</a> 或 <a href="lib/MouseMove.htm">MouseMove</a> 命令) 会让此变量重置为零. 由于此变量的值趋向于以 10 的增量增加, 所以不应该判断它是否等于另一个值. 相反, 应该检查此变量是否大于或小于另一个值. 例如:</p>
      <pre>If A_TimeIdle &gt; 600000
    MsgBox, Last activity was 10 minutes ago</pre>
    </td>
  </tr>
  <tr id="TimeIdlePhysical">
    <td>A_TimeIdlePhysical</td>
    <td>与上面类似, 但在安装了相应的钩子(<a href="lib/_InstallKeybdHook.htm">键盘</a>或<a href="lib/_InstallMouseHook.htm">鼠标</a>) 后会忽略模拟的键击和/或鼠标点击; 即此变量仅反应物理事件. (这样避免了由于模拟键击和鼠标点击而误以为用户存在.) 如果两种钩子都没有安装, 则此变量等同于 A_TimeIdle. 如果仅安装了一种钩子, 那么仅此类型的物理输入才会对 A_TimeIdlePhysical 起作用(另一种/未安装钩子的输入, 包括物理的和模拟的, 都会被忽略).</td>
  </tr>
  <tr id="TimeIdleKeyboard">
    <td>A_TimeIdleKeyboard<br><span class="ver">[v1.1.28+]</span></td>
    <td>如果安装了<a href="lib/_InstallKeybdHook.htm">键盘钩子</a>, 这是自系统上次接收物理键盘输入以来所经过的毫秒数. 否则, 这个变量就等于 A_TimeIdle.</td>
  </tr>
  <tr id="TimeIdleMouse">
    <td>A_TimeIdleMouse<br><span class="ver">[v1.1.28+]</span></td>
    <td>如果安装了<a href="lib/_InstallMouseHook.htm">鼠标钩子</a>, 这是自系统上次收到物理鼠标输入以来所经过的毫秒数. 否则, 这个变量就等于 A_TimeIdle.</td>
  </tr>
</table>
<h3 id="gui">GUI 窗口和菜单栏</h3>
<table class="info">
  <tr>
    <th abbr="Var">变量</th>
    <th abbr="Descr">描述</th>
  </tr>
  <tr id="DefaultGui">
    <td>A_DefaultGui <span class="ver">[v1.1.23+]</span></td>
    <td>当前线程的 GUI<a href="lib/Gui.htm#Default"> 名称或序号.</td>
  </tr>
  <tr id="DefaultListView">
    <td>A_DefaultListView <span class="ver">[v1.1.23+]</span></td>
    <td><a href="lib/ListView.htm">ListView 控件</a>的<a href="lib/Gui.htm#Events">变量名</a>或<a href="lib/Gui.htm#HwndOutputVar">句柄</a>, 这取决与使用了何种 <a href="lib/ListView.htm#BuiltIn">ListView 函数</a>. 如果默认 GUI 中没有 ListView 控件, 此变量为空.</td>
  </tr>
  <tr id="DefaultTreeView">
    <td>A_DefaultTreeView <span class="ver">[v1.1.23+]</span></td>
    <td><a href="lib/TreeView.htm">TreeView 控件</a>的<a href="lib/Gui.htm#Events">变量名</a>或<a href="lib/Gui.htm#HwndOutputVar">句柄</a>, 这取决与使用了何种 <a href="lib/TreeView.htm#BuiltIn">TreeView 函数</a>. 如果默认 GUI 中没有 TreeView 控件, 此变量为空.</td>
  </tr>
  <tr id="Gui">
    <td>A_Gui</td>
    <td>启动了<a href="misc/Threads.htm">当前线程</a>的 <a href="lib/Gui.htm">GUI</a> 的名称或编号. 除非当前线程是由 Gui 控件, 菜单项或 Gui 事件(例如 GuiClose/GuiEscape) 启动的, 否则此变量为空.</td>
  </tr>
  <tr id="GuiControl">
    <td>A_GuiControl</td>
    <td>启动<a href="misc/Threads.htm">当前线程</a>的 GUI 控件的关联变量名. 如果那个控件没有<a href="lib/Gui.htm#Events">关联变量</a>, 则 A_GuiControl 包含此控件的文本/标题中前 63 个字符(这常用来避免给每个按钮分配变量名). 出现后面这些情况时 A_GuiControl 为空: 1) A_Gui 为空; 2) GUI 菜单项或事件(例如 GuiClose/GuiEscape) 启动了当前线程; 3) 那个控件没有关联变量, 也没有标题; 或 4) 最初启动当前线程的控件已经不存在(可能由于 <a href="lib/Gui.htm#Destroy">Gui Destroy</a> 的原因).</td>
  </tr>
  <tr id="GuiWidth">
    <td>A_GuiWidth<br>
	A_GuiHeight</td>
    <td>在 <a href="lib/Gui.htm#GuiSize">GuiSize 子程序</a>中引用时, 它们分别包含了 GUI 窗口的宽度和高度. 它们对应于窗口的工作区, 这是窗口中不包括标题栏, 菜单栏和边框的区域. <span class="ver">[v1.1.11+]</span>: 这些值会受 <a href="lib/Gui.htm#DPIScale">DPI 缩放</a>的影响. </td>
  </tr>
  <tr>
    <td><span id="GuiX"></span><span id="GuiY"></span>A_GuiX<br>
	A_GuiY</td>
    <td>它们包含了 <a href="lib/Gui.htm#GuiContextMenu">GuiContextMenu</a> 和 <a href="lib/Gui.htm#GuiDropFiles">GuiDropFiles</a> 事件中的 X 和 Y 坐标. 这里的坐标相对于窗口的左上角. <span class="ver">[v1.1.11+]</span>: 这些值会受 <a href="lib/Gui.htm#DPIScale">DPI 缩放</a>的影响. </td>
  </tr>
  <tr>
    <td><span id="GuiEvent"></span><span id="GuiControlEvent"></span>A_GuiEvent<br><span class="small80"> 或 A_GuiControlEvent</span></td>
    <td><p>启动<a href="misc/Threads.htm">当前线程</a>的事件类型. 如果当前线程不是由 <a href="lib/Gui.htm">GUI 动作</a>启动的, 则此变量为空. 否则, 它为下列字符串的其中一个:</p>
      <p><strong>Normal:</strong> 此事件是由左键单击和键击(<kbd>&uarr;</kbd>, <kbd>&rarr;</kbd>, <kbd>&darr;</kbd>, <kbd>&larr;</kbd>, <kbd>Tab</kbd>, <kbd>Space</kbd>, 带下划线的快捷键等) 触发的. 此变量的值还可以用于菜单项和特殊的 Gui 事件, 例如 GuiClose 和 GuiEscape.</p>
      <p><strong>DoubleClick:</strong> 此事件是由双击触发的. 注意: 双击中的首次点击仍会引起 <em>Normal</em> 事件首先被接收到. 换句话说, 双击时子程序会运行两次: 一次在首次点击时, 再次是在第二次点击时.</p>
      <p><strong>RightClick:</strong> 仅出现在 <a href="lib/Gui.htm#GuiContextMenu">GuiContextMenu</a>, <a href="lib/ListView.htm">ListViews</a> 和 <a href="lib/TreeView.htm">TreeViews</a>.</p>
      <p><strong>上下文相关值:</strong> 要了解详情请参阅 <a href="lib/Gui.htm#GuiContextMenu">GuiContextMenu</a>, <a href="lib/Gui.htm#GuiDropFiles">GuiDropFiles</a>, <a href="lib/GuiControls.htm#Slider">Slider</a>, <a href="lib/GuiControls.htm#MonthCal">MonthCal</a>, <a href="lib/ListView.htm">ListView</a> 和 <a href="lib/TreeView.htm">TreeView</a>. </p>
    </td>
  </tr>
  <tr id="EventInfo">
    <td>A_EventInfo</td>
    <td><p>包含下列事件的额外信息:</p>
      <ul>
        <li><a href="misc/Clipboard.htm#OnClipboardChange#label">OnClipboardChange 标签</a></li>
        <li><a href="Hotkeys.htm#Wheel">鼠标滚轮热键</a>(WheelDown/Up/Left/Right)</li>
        <li><a href="lib/OnMessage.htm">OnMessage()</a></li>
        <li><a href="lib/RegisterCallback.htm">RegisterCallback()</a></li>
          <li><a href="misc/RegExCallout.htm">Regular Expression Callouts</a></li>
        <li><a href="lib/Gui.htm#label">GUI 事件</a>, 即 <a href="lib/Gui.htm#GuiContextMenu">GuiContextMenu</a>, <a href="lib/Gui.htm#GuiDropFiles">GuiDropFiles</a>, <a href="lib/GuiControls.htm#ListBox">ListBox</a>, <a href="lib/ListView.htm">ListView</a>, <a href="lib/TreeView.htm">TreeView</a> 和 <a href="lib/GuiControls.htm#StatusBar">StatusBar</a>. 如果一个事件没有额外的信息, 那么 A_EventInfo 的值为 0.</li>
      </ul></td>
  </tr>
</table>
<p class="note"><strong>注意:</strong> 与类似 A_ThisHotkey 这样的变量不同, 每个<a href="misc/Threads.htm">线程</a>会为 A_Gui, A_GuiControl, A_GuiX/Y, A_GuiEvent 和 A_EventInfo 保存它自己本身的值. 因此, 如果一个线程被另一个中断, 在这个线程恢复时它仍将看到这些变量的原来/正确的值.</p>
<h3 id="h">热键, 热字串和自定义菜单项</h3>
<table class="info">
  <tr>
    <th abbr="Var">变量</th>
    <th abbr="Descr">描述</th>
  </tr>
  <tr id="ThisMenuItem">
    <td>A_ThisMenuItem</td>
    <td>最近选择的<a href="lib/Menu.htm">自定义菜单项</a>的名称(没有则为空).</td>
  </tr>
  <tr id="ThisMenu">
    <td>A_ThisMenu</td>
    <td>A_ThisMenuItem 所在菜单的名称.</td>
  </tr>
  <tr id="ThisMenuItemPos">
    <td>A_ThisMenuItemPos</td>
    <td>表示 A_ThisMenuItem 在 A_ThisMenu <u>当前</u> 位置的编号. 菜单中首个项目为 1, 第二项为 2, 依此类推. 菜单分隔线也计算在内. 如果 A_ThisMenuItem 为空或已不存在于 A_ThisMenu 中, 则此变量为空. 如果 A_ThisMenu 已不存在, 则此变量也为空.</td>
  </tr>
  <tr id="ThisHotkey">
    <td>A_ThisHotkey</td>
    <td><p>最近执行的<a href="Hotkeys.htm">热键</a>或<a href="Hotstrings.htm">非自动替换热字串</a>的按键名称(如果没有则为空), 例如 #z. 如果<a href="misc/Threads.htm">当前线程</a>被其他热键或热字串中断, 那么此变量的值会变化, 所以如果之后需要在子程序中使用原来的值, 则必须马上把它复制到另一个变量中.</p>
      <p>首次创建热键时(通过 <a href="lib/Hotkey.htm">Hotkey 命令</a>或脚本中的<a href="Hotkeys.htm">双冒号标签</a>), 其键名及其修饰符的顺序成为此热键的固定名称, 由热键的所有<a href="lib/_IfWinActive.htm#variant">变体</a>共享.</p>
      <p>当第一次创建热字符串时 -- 通过 <a href="lib/Hotstring.htm">Hotstring 函数</a>或脚本中的<a href="Hotstrings.htm">双冒号标签</a> -- 它的触发字符串和选项字符序列成为该热字符串的永久名称.</p>
      <p>另请参阅: <a href="#ThisLabel">A_ThisLabel</a></p></td>
  </tr>
  <tr id="PriorHotkey">
    <td>A_PriorHotkey</td>
    <td>除了保存前一次热键的名称外, 其他的与上面相同. 如果没有它会为空.</td>
  </tr>
  <tr id="PriorKey">
    <td>A_PriorKey</td>
    <td><span class="ver">[v1.1.01+]</span>: 在最近按键按下或按键释放前最后按下的按键名称, 如果在按键历史中没有适用的按键按下则为空. 不包括由 AutoHotkey 脚本生成的所有输入. 要使用此变量, 首先必须安装<a href="lib/_InstallKeybdHook.htm">键盘钩子</a>或<a href="lib/_InstallMouseHook.htm">鼠标钩子</a>同时启用<a href="lib/KeyHistory.htm">按键历史</a>.</td>
  </tr>
  <tr id="TimeSinceThisHotkey">
    <td>A_TimeSinceThisHotkey</td>
    <td>从 A_ThisHotkey 按下后到现在经过的毫秒数. 如果 A_ThisHotkey 为空, 则此变量的值为 -1.</td>
  </tr>
  <tr id="TimeSincePriorHotkey">
    <td>A_TimeSincePriorHotkey</td>
    <td>从 A_PriorHotkey 按下后到现在经过的毫秒数. 如果 A_PriorHotkey 为空, 则此变量的值为 -1.</td>
  </tr>
  <tr id="EndChar">
    <td>A_EndChar</td>
    <td>用户最近按下的触发了<a href="Hotstrings.htm">非自动替换热字串</a>的<a href="Hotstrings.htm#EndChars">终止符</a>. 如果不需要终止符(由于使用了 * 选项), 那么此变量将为空.</td>
  </tr>
</table>
<h3 id="os">操作系统和用户信息</h3>
<table class="info">
  <tr>
    <th abbr="Var">变量</th>
    <th abbr="Descr">描述</th>
  </tr>
  <tr id="ComSpec">
    <td>ComSpec <span class="ver">[v1.0.43.08+]</span><br>
    A_ComSpec <span class="ver">[v1.1.28+]</span></td>
    <td>
      <p>此变量的值与 ComSpec 环境变量一样, 这通常是命令提示符的可执行文件(cmd.exe) 的完全路径. 常与 <a href="lib/Run.htm">Run/RunWait</a> 一起使用. 例如:</p>
      <pre class="NoIndent no-highlight">C:\Windows\system32\cmd.exe</pre>
    </td>
  </tr>
  <tr id="Temp">
    <td>A_Temp<br>
	<span class="ver">[v1.0.43.09+]</span></td>
    <td>存放临时文件的文件夹的完整路径和名称. 它的值从下列的其中一个位置获取(按顺序): 1) <a href="Concepts.htm#environment-variables">环境变量</a> TMP, TEMP 或 USERPROFILE; 2) Windows 目录. 例如:</p>
    <pre class="NoIndent no-highlight">C:\Users\&lt;UserName&gt;\AppData\Local\Temp</pre>
  </td>
  </tr>
  <tr id="OSType">
    <td>A_OSType</td>
    <td>正在运行的操作系统类型. 由于 AutoHotkey 1.1 仅支持基于 NT 的操作系统, 所以此变量总是为 WIN32_NT. 旧版本的 AutoHotkey 运行在 Windows 95/98/ME 时会返回 WIN32_WINDOWS. </td>
  </tr>
  <tr id="OSVersion">
    <td>A_OSVersion</td>
    <td><p>下列字符串中的一个(如果存在): WIN_7 <span class="ver">[需要 AHK_L 42+]</span>, WIN_8 <span class="ver">[需要 v1.1.08+]</span>, WIN_8.1 <span class="ver">[需要 v1.1.15+]</span>, WIN_VISTA, WIN_2003, WIN_XP, WIN_2000.</p>
    <p>在 AutoHotKey 的可执行文件或编译后的脚本属性里应用兼容性设置会让操作系统报告不同的版本号, 该版本号由 A_OSVersion 反映.</p>
    <p><span class="ver">[v1.1.20+]</span>: 如果系统版本没有被识别成上述版本, 会返回一个 "major.minor.build" 形式的字符串. 例如, <code>10.0.14393</code> 为 Windows 10 build 14393, 也称为 1607 版.</p>
      <pre><em>; 这个示例已过时了, 里面的这些操作系统都不再受支持. </em>
if A_OSVersion in WIN_NT4,WIN_95,WIN_98,WIN_ME  <em>; 注: 逗号两边没有空格. </em>
{
    MsgBox This script requires Windows 2000/XP or later.
    ExitApp
}</pre>
    </td>
  </tr>
  <tr id="Is64bitOS">
    <td>A_Is64bitOS</td>
    <td><span class="ver">[v1.1.08+]</span>: 当操作系统为 64 位则值为 1(真), 为 32 位则为 0(假). </td>
  </tr>
  <tr id="PtrSize">
    <td>A_PtrSize</td>
    <td><span class="ver">[AHK_L 42+]</span>: 包含指针的大小值, 单位为字节. 值为 4(32 位) 或 8(64 位), 取决于运行当前脚本的执行程序的类型. </td>
  </tr>
  <tr id="Language">
    <td>A_Language</td>
    <td>当前系统的默认语言, 值为<a href="misc/Languages.htm">这些 4 位数字编码</a>的其中一个.</td>
  </tr>
  <tr id="ComputerName">
    <td>A_ComputerName</td>
    <td>在网络上看到的计算机名称.</td>
  </tr>
  <tr id="UserName">
    <td>A_UserName</td>
    <td>运行当前脚本的用户的登录名.</td>
  </tr>
  <tr id="WinDir">
    <td>A_WinDir</td>
    <td>Windows 目录. 例如: <code>C:\Windows</code></td>
  </tr>
  <tr id="ProgramFiles">
    <td>A_ProgramFiles<br>
	或 ProgramFiles</td>
    <td>
      <p>Program Files 目录(例如 <code>C:\Program Files</code> 或者 <code>C:\Program Files (x86)</code>). 一般来说和<a href="Concepts.htm#environment-variables">环境变量</a> <em>ProgramFiles</em> 一样.</p>
      <p>在 <a href="#Is64bitOS">64 位系统</a>(非 32 位系统) 上适用:</p>
      <ul>
        <li>如果可执行文件(EXE) 以 32 位脚本运行的时候, A_ProgramFiles 返回路径为 "Program Files (x86)" 目录.</li>
        <li>对于 32 位的进程, <em>ProgramW6432</em> 环境变量指向 64 位 Program Files 目录. 在 Windows 7 和更高版本上, 对于 64 位的进程也是这样设置的.</li>
        <li>而 <em>ProgramFiles(x86)</em> 环境变量指向 32 位 Program Files 目录.</li>
      </ul>
	  <p><span class="ver">[1.0.43.08+]</span>: 前缀 A_ 可以省略, 这样有助于自然过渡到 <a href="lib/_NoEnv.htm">#NoEnv</a>.</p>
	  </td>
  </tr>
  <tr id="AppData">
    <td>A_AppData<br>
	<span class="ver">[v1.0.43.09+]</span></td>
    <td>
      <p>当前用户的应用程序数据文件夹的完整路径和名称. 例如:</p>
      <pre class="NoIndent no-highlight">C:\Users\&lt;UserName&gt;\AppData\Roaming</pre>
    </td>
  </tr>
  <tr id="AppDataCommon">
    <td>A_AppDataCommon<br>
	<span class="ver">[v1.0.43.09+]</span></td>
    <td>
      <p>所有用户的应用程序数据文件夹的完整路径和名称. 例如:</p>
      <pre class="NoIndent no-highlight">C:\ProgramData</pre>
    </td>
  </tr>
  <tr id="Desktop">
    <td>A_Desktop</td>
    <td>
      <p>当前用户的桌面文件夹的完整路径和名称. 例如:</p>
      <pre class="NoIndent no-highlight">C:\Users\&lt;UserName&gt;\Desktop</pre>
    </td>
  </tr>
  <tr id="DesktopCommon">
    <td>A_DesktopCommon</td>
    <td>
      <p>所有用户的桌面文件夹的完整路径和名称. 例如:</p>
      <pre class="NoIndent no-highlight">C:\Users\Public\Desktop</pre>
    </td>
  </tr>
  <tr id="StartMenu">
    <td>A_StartMenu</td>
    <td>
      <p>当前用户的开始菜单文件夹的完整路径和名称. 例如:</p>
      <pre class="NoIndent no-highlight">C:\Users\&lt;UserName&gt;\AppData\Roaming\Microsoft\Windows\Start Menu</pre>
    </td>
    </td>
  </tr>
  <tr id="StartMenuCommon">
    <td>A_StartMenuCommon</td>
    <td>
      <p>所有用户的开始菜单文件夹的完整路径和名称. 例如:</p>
      <pre class="NoIndent no-highlight">C:\ProgramData\Microsoft\Windows\Start Menu</pre>
    </td>
  </tr>
  <tr id="Programs">
    <td>A_Programs</td>
    <td>
      <p>当前用户的开始菜单中程序文件夹的完整路径和名称. 例如:</p>
      <pre class="NoIndent no-highlight">C:\Users\&lt;UserName&gt;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs</pre>
    </td>
  </tr>
  <tr id="ProgramsCommon">
    <td>A_ProgramsCommon</td>
    <td>
      <p>所有用户的开始菜单中程序文件夹的完整路径和名称. 例如:</p>
      <pre class="NoIndent no-highlight">C:\ProgramData\Microsoft\Windows\Start Menu\Programs</pre>
    </td>
  </tr>
  <tr id="Startup">
    <td>A_Startup</td>
    <td>
      <p>当前用户的开始菜单中启动文件夹的完整路径和名称. 例如:</p>
      <pre class="NoIndent no-highlight">C:\Users\&lt;UserName&gt;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</pre>
    </td>
  </tr>
  <tr id="StartupCommon">
    <td>A_StartupCommon</td>
    <td>
      <p>所有用户的开始菜单中启动文件夹的完整路径和名称. 例如:</p>
      <pre class="NoIndent no-highlight">C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup</pre>
    </td>
  </tr>
  <tr id="MyDocuments">
    <td>A_MyDocuments</td>
    <td>
      <p>当前用户 "我的文档" 文件夹的完整路径和名称. 与大多数类似变量不同, 当此文件夹为驱动器的根目录时, 此变量的值不包含最后的反斜杠(例如, 它的值是 <code>M:</code> 而不是 <code>M:\</code>). 例如:</p>
      <pre class="NoIndent no-highlight">C:\Users\&lt;UserName&gt;\Documents</pre>
    </td>
  </tr>
  <tr id="IsAdmin">
    <td>A_IsAdmin</td>
    <td><p>如果当前用户有管理员权限, 则值为 1, 否则为 0.</p>
    <p id="RequireAdmin">要使脚本以管理员权限重新启动(或显示提示向用户请求管理员权限), 请使用 <a href="lib/Run.htm#RunAs">Run *RunAs</a>. 但是请注意, 以管理员权限运行脚本会导致脚本启动的所有程序也以管理员权限运行. 对于可能的替代方案, 请参阅<a href="FAQ.htm#uac">常见问题(FAQ)</a>.</p>
    </td>
  </tr>
  <tr id="Screen">
    <td><p>A_ScreenWidth<br>
	A_ScreenHeight</p></td>
    <td><p>主监视器的宽度和高度, 单位为像素(例如 1024 和 768).</p>
      <p>要获取多显示器系统中其他显示器的尺寸, 请使用 <a href="lib/SysGet.htm">SysGet</a>.</p>
      <p>要获取整个桌面(即使它横跨多个显示器) 的宽度和高度, 请使用下面的例子:</p>
<pre>
<a href="lib/SysGet.htm">SysGet</a>, VirtualWidth, 78
<a href="lib/SysGet.htm">SysGet</a>, VirtualHeight, 79
</pre>
    <p>此外, 使用 <a href="lib/SysGet.htm">SysGet</a> 可以获取显示器的工作区域, 它比显示器的整个区域小, 因为它不包括任务栏和其他注册的桌面工具栏.</p></td>
  </tr>
  <tr id="ScreenDPI">
    <td>A_ScreenDPI <span class="ver">[v1.1.11+]</span></td>
    <td>在屏幕宽度上每逻辑英寸的像素数. 在多显示器的系统中, 这个值对于所有的显示器都是一样的. 在大多数系统中该值为 96; 它取决于系统文本大小(DPI) 设置. 另请参阅 <a href="lib/Gui.htm#DPIScale">Gui -DPIScale</a>. </td>
  </tr>
  <tr id="IPAddress">
    <td>A_IPAddress1 到 4</td>
    <td>计算机中前 4 个网卡的 IP 地址.</td>
  </tr>
</table>
<h3 id="misc">杂项</h3>
<table class="info">
  <tr>
    <th abbr="Var">变量</th>
    <th abbr="Descr">描述</th>
  </tr>
  <tr id="Cursor">
    <td>A_Cursor</td>
    <td><p>当前显示的鼠标光标类型. 其值为下列单词的其中一个: AppStarting(程序启动, 后台运行--箭头+等待), Arrow(箭头, 正常选择--标准光标), Cross(十字, 精确选择), Help(帮助, 帮助选择--箭头+问号), IBeam(工字光标, 文本选择--输入), Icon, No(No, 不可用--圆圈加反斜杠), Size, SizeAll(所有尺寸, 移动--四向箭头), SizeNESW(东南和西北尺寸, 沿对角线调整 2--双箭头指向东南和西北), SizeNS(南北尺寸, 垂直调整--双箭头指向南北), SizeNWSE(西北和东南尺寸, 沿对角线调整 1--双箭头指向西北和东南), SizeWE(东西尺寸, 水平调整--双箭头指向东西), UpArrow(向上箭头, 候选--指向上的箭头), Wait(等待, 忙--沙漏或圆圈), Unknown(未知). 与 size 指针类型一起的首字母表示方向, 例如 NESW = NorthEast(东北)+SouthWest(西南). 手型指针(点击和抓取) 属于 Unknown 类别.</p></td>
  </tr>
  <tr id="Caret">
    <td>A_CaretX<br>
	A_CaretY</td>
    <td><p>当前光标(文本插入点) 的 X 和 Y 坐标. 如果没有使用 <a href="lib/CoordMode.htm">CoordMode</a> 使得坐标相对于整个屏幕, 默认坐标相对于活动窗口. 如果没有活动窗口或无法确定文本插入点的位置, 则这两个变量为空.</p>
      <p>下面这个脚本可以让您在四处移动文本插入点时, 查看显示在自动更新工具提示上的当前位置. 注意在某些窗口(例如某些版本的 MS Word) 会不管文本插入点的实际位置如何都报告同样的位置.</p>
<pre>
#Persistent
SetTimer, WatchCaret, 100
return
WatchCaret:
  ToolTip, X%A_CaretX% Y%A_CaretY%, A_CaretX, A_CaretY - 20
return
</pre>
    </td>
  </tr>
  <tr id="Clipboard">
    <td>Clipboard</td>
    <td rowspan="2">可用于获取或设置操作系统剪贴板的内容. 有关详情, 请参阅<a href="misc/Clipboard.htm">剪贴板</a>.</td>
  </tr>
  <tr id="A_Clipboard">
    <td>A_Clipboard <span class="ver">[v1.1.35+]</span></td>
  </tr>
  <tr id="ClipboardAll">
    <td>ClipboardAll</td>
    <td>剪贴板中的完整内容(包含格式和文本). 有关详情, 请参阅 <a href="misc/Clipboard.htm#ClipboardAll">ClipboardAll</a>.</td>
  </tr>
  <tr id="ErrorLevel">
    <td>ErrorLevel</td>
    <td>这个变量由一些命令设置, 用于指示其成功或失败. 有关详情, 请参阅 <a href="misc/ErrorLevel.htm">ErrorLevel</a>.</td>
  </tr>
  <tr id="LastError">
    <td>A_LastError</td>
    <td>操作系统 GetLastError() 函数或最近 COM 对象调用返回的结果. 要了解详情, 请参阅 <a href="lib/DllCall.htm#LastError">DllCall()</a> 和 <a href="lib/Run.htm#LastError">Run/RunWait</a>.</td>
  </tr>
  <tr id="TrueFalse">
    <td>True<br />False</td>
    <td><p>包含 1 和 0. 它们可以用来使脚本更具可读性. 有关详情, 请参阅<a href="Concepts.htm#boolean">布尔值</a>.</p>
    </td>
  </tr>
</table>
<h3 id="loop">Loop</h3>
<table class="info">
  <tr>
    <th abbr="Var">变量</th>
    <th abbr="Descr">描述</th>
  </tr>
  <tr id="Index">
    <td>A_Index</td>
    <td>可用于获取或设置当前循环迭代的次数(64 位整数). 第一次循环体执行时, 它为 1. 第二次, 它的值为 2; 依次类推. 如果一个内循环被外循环包围, 那么内循环优先. A_Index 在<a href="Language.htm#loop-statement">所有类型的循环</a>中都起作用, 但在循环语句外值为 0.</td>
  </tr>
  <tr>
    <td>A_LoopFileName 等</td>
    <td>此变量和其他相关变量仅在<a href="lib/LoopFile.htm">文件循环</a>中有效.</td>
  </tr>
  <tr>
    <td>A_LoopRegName 等</td>
    <td>此变量和其他相关变量仅在<a href="lib/LoopReg.htm">注册表循环</a>中有效.</td>
  </tr>
  <tr>
    <td>A_LoopReadLine</td>
    <td>请参阅<a href="lib/LoopReadFile.htm">文件读取循环</a>.</td>
  </tr>
  <tr>
    <td>A_LoopField</td>
    <td>请参阅<a href="lib/LoopParse.htm">解析循环</a>.</td>
  </tr>
</table>

<h2 id="cap">变量的容量和占用内存</h2>
<ul>
  <li>每个变量最多可以含有 64 MB 的文本(使用 <a href="lib/_MaxMem.htm">#MaxMem</a> 可以突破这个限制). </li>
  <li>当赋值给变量比当前更长的内容时, 会自动分配额外的系统内存给这个变量.</li>
  <li>通过赋值为空可以释放大变量占用的内存, 例如 <code>Var := ""</code>. </li>
  <li>脚本可以创建的变量数量没有限制. 程序设计用来支持至少几百万的变量而不会出现明显的性能下降.</li>
  <li>接受数值输入的命令, 函数和表达式通常可以支持 15 位的浮点数精度. 对于整数, 可以支持 64 位有符号整数, 其范围从 -9223372036854775808(-0x8000000000000000) 到 9223372036854775807(0x7FFFFFFFFFFFFFFF). 此范围外的任何整数或数字字符串不受支持, 并且当作为数字使用时可能产生错误的结果. 与之相比, 整数的算数运算结果超出此范围时会产生溢出(例如 0x7FFFFFFFFFFFFFFF + 1 = -0x8000000000000000).</li>
</ul>
</body>
</html>