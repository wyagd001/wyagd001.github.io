<!DOCTYPE HTML>
<html lang="zh">
<head>
<title>变量和表达式 - 定义 &amp; 使用 | AutoHotkey v2</title>
<meta name="description" content="Learn details about variables, expressions, operators, built-in variables and capacity and memory of variables." />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>变量和表达式</h1>

<h2 id="toc">目录</h2>
<ul>
  <li><a href="#Intro">变量</a></li>
  <li><a href="#Expressions">表达式</a></li>
  <li><a href="#Operators">表达式中的运算符</a></li>
  <li><a href="#BuiltIn">内置变量</a></li>
  <li><a href="#cap">变量的容量和占用内存</a></li>
</ul>
<span id="Variables"></span><h2 id="Intro">变量</h2>
<p>有关一般说明和变量如何工作的详细信息, 请参阅<a href="Concepts.htm#variables">变量</a>.</p>
<p id="assigning"><strong>给变量赋值:</strong> 要将字符串或数字存储在变量中, 使用<a href="#AssignOp">冒号-等号运算符(:=)</a> 后跟着数字, 加引号的字符串或其他类型的<a href="Language.htm#expressions">表达式</a>. 例如:</p>
<pre>MyNumber := 123
MyString := "这是原义字符串."
CopyOfVar := Var</pre>
<p>变量不能被显式删除, 但是它的前一个值可以通过赋值一个新的值来释放, 比如一个空字符串:</p>
<pre>MyVar := ""</pre>
<p>变量也可以间接赋值, 通过<a href="#ref">获取它的引用</a>, 并使用<a href="#deref">双重解引</a>或将其传递给一个函数. 例如:</p>
<pre><a href="lib/MouseGetPos.htm">MouseGetPos</a> &amp;x, &amp;y</pre>
<p>读取一个未赋值的变量的值被视为一个错误. <a href="lib/IsSet.htm">IsSet</a> 可以用来检测这种情况.</p>
<p id="retrieving"><strong>检索变量的内容:</strong> 若要将变量的内容包含在字符串中, 请使用<a href="#concat">连接</a>或 <a href="lib/Format.htm">Format</a>. 例如:</p>
<pre><a href="lib/MsgBox.htm">MsgBox</a> "变量的值是 " . Var . "."
MsgBox "变量 Var 的值为 " Var "."
MsgBox Format("Var 的值为 {1}.", Var)
</pre>
<p>子表达式可以以同样的方式与字符串组合. 例如:</p>
<pre>MsgBox("X 和 Y 的和是 " . (X + Y))
</pre>
<p><strong>变量的比较:</strong> 请阅读下面表达式部分中关于不同类型比较的重要提示.</p>
<h2 id="Expressions">表达式</h2>
<p class="note">有关结构化概述和进一步说明, 请参阅<a href="Language.htm#expressions">表达式</a>.</p>
<p>表达式用于对一系列变量, 原义字符串和/或原义数字执行一个或多个运算.</p>
<p>表达式中的普通单词被解释为变量名. 因此, 原义的字符串必须用双引号括起来, 以便与变量区分开来. 例如:</p>
<pre>if (CurrentSetting &gt; 100 or FoundColor != "Blue")
    MsgBox "设置太高或出现错误的颜色."</pre>
<p>在上面的例子中, "Blue" 出现在引号中, 因为它是一个原义的字符串. 单引号(&apos;) 和双引号(") 的作用是相同的, 除了用单引号括起来的字符串可以包含原义双引号, 反之亦然. 因此, 要在原义字符串中包含 <em>真实的</em> 引号, 可以<a href="misc/EscapeChar.htm">转义</a>引号或将字符串括在相反类型的引号中. 例如:</p>
<pre>MsgBox "她说, `"一天一个苹果.`""
MsgBox &apos;她说, "一天一个苹果."&apos;</pre>
<p><strong>空字符串:</strong> 若要在表达式中指定空字符串, 请使用一对空的双引号. 例如, 当 <em>MyVar</em> 非空时, 语句 <code>if (MyVar != "")</code> 的结果为真.</p>
<p><strong>保存表达式的结果:</strong> 要把结果赋值给变量, 请使用<a href="#AssignOp">冒号-等号运算符(:=)</a>. 例如:</p>
<pre>NetPrice := Price * (1 - Discount/100)</pre>
<p id="Boolean"><strong>布尔值:</strong> 若要计算表达式结果为真还是假时(如 IF-语句), 结果为空或零被视为假(false), 而其他所有结果都视为真(true). 例如, 仅当 ItemCount 为空或 0 时, 语句 <code>if ItemCount</code> 的结果才为假. 类似的, 表达式 <code>if not ItemCount</code> 将产生相反的结果.</p>
<p>诸如 <b>NOT</b>/<b>&gt;</b>/<b>=</b>/<b>&lt;</b> 之类的运算符自动生成一个真值或假值: 真值时结果为 1, 而假值时为 0. 然而, <b>AND</b>/<b>OR</b> 运算符总是生成一个输入值. 例如, 在以下表达式, 如果 A_Index 大于 5, 变量 <em>Done</em> 赋值为 1, 其他情况下为 <em>FoundIt</em> 的值:</p>
<pre>Done := A_Index &gt; 5 or FoundIt</pre>
<p>如上所述, 可以通过将变量设为空或赋值为 0, 来使变量来保存假值. 利用这种特性, 可以使用简写语句 <code>if Done</code> 来检查变量 Done 是真还是假.</p>
<p><span id="True"></span><span id="False"></span>在表达式中, 关键字 <em>true</em> 和 <em>false</em> 解析为 1 和 0. 使用它们可以使脚本更易于阅读, 如以下示例所示:</p>
<pre>CaseSensitive := false
ContinueSearch := true</pre>
<p id="numbers"><strong>整数和浮点数:</strong> 在表达式中, 如果数字包含小数点或科学计数符号, 则认为它们是浮点数; 否则, 否则视为整数. 对于大多数运算符 -- 如加法和乘法 -- 只要其中的一个输入是浮点数, 那么结果也将是浮点数.</p>
<p>在表达式和非表达式中, 整数都可以用十六进制或十进制格式书写. 十六进制数总是以前缀 0x 开头. 例如, <code>Sleep 0xFF</code> 等同于 <code>Sleep 255</code>. 浮点数可以选择用科学记数法书写, 带或不带小数点(例如 <code>1e4</code> 或 <code>-2.1E-4</code>).</p>
<p>在脚本开始执行之前, 在表达式中, 未加双引号的原义数字(如 <code>128</code>, <code>0x7F</code> 和 <code>1.0</code>), 被转换为纯数字, 因此将数字转换为字符串可能会产生与原始文字值不同的值. 例如:</p>
<pre>MsgBox(0x7F)  <em>; 显示 128</em>
MsgBox(1.00)  <em>; 显示 1.0</em></pre>

<h2 id="Operators">表达式中的运算符</h2>
<p class="note">有关运算符的一般信息, 请参阅<a href="Language.htm#operators">运算符</a>.</p>
<p>除了下面提到的, 数学运算中涉及的任何空值(空字符串) 或非数字值都<strong>不会</strong>假定为零. 相反, 会抛出 <a href="lib/Error.htm#TypeError">TypeError</a>. 如果未使用 <a href="lib/Try.htm">Try</a>, 默认情况下, 未处理的异常将导致一个错误对话框.</p>

<h3 id="operators">表达式运算符(按优先级降序排列)</h3>
<table class="info">
  <tr>
    <th class="center">运算符</th>
    <th abbr="Descr">描述</th>
  </tr>
  <tr id="deref">
    <td class="center bold">%Expr%</td>
    <td>
      <p><strong>解引用</strong>或<strong>名称替换</strong>.</p>
      <p>当 <em>Expr</em> 计算为 <a href="Concepts.htm#variable-references">VarRef</a> 时, <code>%Expr%</code> 访问相应的变量. 例如, <code>x := &amp;y</code> 取 <em>y</em> 的引用并将其赋值给 <em>x</em>, 那么 <code>%x% := 1</code> 赋值给变量 <em>y</em>, 而 <code>%x%</code> 读取其值.</p>
      <p>否则, 子表达式 <em>Expr</em> 的值被用作变量或属性的名称或部分名称. 这使得脚本可以引用一个变量或属性, 其名称是由计算 <em>Expr</em> 确定的, 它通常是另一个变量. 变量不能被动态创建, 但是如果一个变量已经在脚本中的某个地方被声明或被非动态引用, 那么它可以被动态赋值.</p>
      <p class="note"><strong>注意:</strong> 子表达式 <em>Expr</em> 的 <u>结果</u> 必须是要访问的变量或属性的名称或部分名称.</p>
      <p>由于存在歧义, 百分号不能直接在 <em>Expr</em> 中使用, 但可以在括号中嵌套. 否则, <em>Expr</em> 可以是任何表达式.</p>
      <p>如果有任何相邻的 <em>%Expr%</em> 序列和部分<a href="Concepts.htm#names">名称</a>(它们之间没有任何空格或其他字符), 则将它们组合成一个单一的名称.</p>
      <p>如果变量并不存在, 或者它未初始化并且它的值正在被读取, 则通常抛出一个 <a href="lib/Error.htm">Error</a>. 可以使用 <a href="#or-maybe">or-maybe 运算符(??)</a> 通过提供默认值来避免这种情况. 例如: <code>%'novar'% ?? 42</code>.</p>
      <p>虽然这在历史上被称为 "双重解引", 但当 <em>Expr</em> 不包含一个变量(第一重解引), 以及当产生的变量是赋值的目标, 而不是解引用(第二重解引), 这个术语是不准确的.</p>
    </td>
  </tr>
  <tr id="objdot">
    <td class="center bold">x.y<br>x.%z%</td>
    <td><strong>成员访问</strong>. 获取或设置一个值或调用对象 <i>x</i> 的方法, 此处 <i>y</i> 是个原义名称, 而 <em>z</em> 是一个表达式, 它的值是一个名称. 请参阅<a href="Objects.htm#Usage_Objects">对象语法</a>.</td>
  </tr>
  <tr id="maybe">
    <td class="center"><em>var</em><strong>?</strong></td>
    <td>
      <p><strong>Maybe</strong>. 允许未设置的变量. 这只在将变量传递给可选参数, 数组元素或文本对象; 或直接赋值的右边时有效. 问号后面必须跟随下列符号之一(忽略空白): <code class="no-highlight">)]},:</code>. 变量可以通过<a href="#ternary">三元运算符</a>或在 <a href="#and">AND</a>/<a href="#or">OR</a> 的右边有条件地传递.</p>
      <p>变量通常是一个可选参数, 但可以是任何变量. 对于不是函数参数的变量, 如果有对该变量的其他引用但没有赋值, 在加载时仍然可能显示 <a href="lib/_Warn.htm#VarUnset">VarUnset 警告</a>.</p>
      <p>该操作符目前仅支持变量. 要在更一般的情况下显式或有条件地省略参数, 请使用 <code>unset</code> 关键字.</p>
      <p>另请参阅: <a href="Language.htm#unset">unset(可选参数)</a></p>
    </td>
  </tr>
  <tr id="IncDec">
    <td class="center bold">++<br>
    --</td>
    <td>
      <p><strong>前置和后置的自增/自减</strong>. 从变量中增加或减去 1. 运算符可以放在变量名的前面或后面. 如果放在变量名的 <em>前面</em>, 则执行自增/减运算并把结果用于下一运算(在这种情况下结果是一个变量引用). 例如, <code>Var := ++X</code> 递增 X 然后将其值赋给 <em>Var</em>. 相反, 如果运算符放在变量名的 <em>后面</em>, 结果是在执行运算之前的 X 值. 例如, <code>Var := X++</code> 递增 X, 但 <em>Var</em> 接收 X 在递增之前的值.</p>
      <p>这些运算符还可以与对象的属性一起使用, 如 <code>myArray.Length++</code> 或 <code>--myArray[i]</code>. 在这些情况下, 子表达式的结果总是一个数字, 而不是一个变量引用.</p>
    </td>
  </tr>
  <tr id="pow">
    <td class="center bold">**</td>
    <td>
      <p><strong>幂</strong>. 示例用法: <code>Base**Exponent</code>. 底数(<em>Base</em>) 和指数(<em>Exponent</em>) 都可以为小数. 如果 <em>指数</em> 为负数, 即使 <em>底数</em> 和 <em>指数</em> 都为整数, 结果也会被格式化为浮点数. 因为 ** 的优先级高于一元负号, 所以, <code>-2**2</code> 的计算过程和 <code>-(2**2)</code> 一样, 且得到结果 -4. 因此, 要计算原义负数的幂, 需要把它们包围在括号中, 如 <code>(-2)**2</code>.</p>
      <p>幂运算符是右结合的. 例如, <code>x ** y ** z</code> 计算为 <code>x ** (y ** z)</code>.</p>
      <p class="note"><strong>注意:</strong> 不支持 <em>底数</em> 为负数且 <em>指数</em> 为小数的情况, 如 <code>(-2)**0.5</code>; 尝试它将导致抛出异常. 但 <code>(-2)**2</code> 和 <code>(-2)**2.0</code> 都是支持的. 如果 <em>底数</em> 和 <em>指数</em> 都为 0, 结果未定义并抛出异常.</p>
    </td>
  </tr>
  <tr id="unary">
    <td class="center bold">-<br>
    !<br>
    ~<br>
    &amp;</td>
    <td>
      <p><strong>一元负号(-):</strong> 反转其运算元的符号.</p>
      <p><strong>一元正号(+):</strong> <code>+N</code> 等同于 <code>-(-N)</code>. 应用于纯数字时无效, 但可用于将数字字符串转换为纯数字.</p>
      <p><strong>逻辑非(!):</strong> 如果运算元为空或 0, 那么逻辑非的结果为 1, 这表示 "true". 否则, 结果为 0(false). 例如: <code>!x or !(y and z)</code>. 注意: 单词 NOT 和 <strong>!</strong> 含义相同, 但 <strong>!</strong> 优先级更高. 允许使用连续的一元运算符, 例如 <code><strong>!!</strong>Var</code>, 因为它们是按从右到左的顺序计算.</p>
      <p><strong>按位非(~):</strong> 此运算符对运算元按位取反. 当使用 64 位有符号整数时, 正的输入值始终给出负的结果, 反之亦然. 例如, <code>~0xf0f</code> 等于 -0xf10(-3856), 二进制等于 0xfffffffffffff0f0. 如果希望使用无符号的 32 位值, 可以使用 <code><i>result</i> &amp; 0xffffffff</code> 截断结果. 如果操作数是一个浮点值, 则抛出 <a href="lib/Error.htm#TypeError">TypeError</a>.</p>
      <p id="ref"><strong>引用(&amp;):</strong> 创建一个 VarRef, 它是一个代表变量引用的值. VarRef 可以用来间接访问目标变量. 例如, <code>ref := &amp;target</code> 接着的 <code>%ref% := 1</code> 将把值 1 赋值给 <em>target</em>. VarRef 通常会被传递给一个函数, 但也可以存储在一个数组或属性中. 另请参阅: <a href="#deref">Dereference</a>, <a href="Functions.htm#ByRef">ByRef</a>.</p>
      <p>目前不支持对内置变量(如 <a href="lib/A_Clipboard.htm">A_Clipboard</a>) 的引用, 除非是直接传递给内置函数的 <em>OutputVar</em> 参数.</p>
    </td>
  </tr>
  <tr id="MulDiv">
    <td class="center bold">*<br>
    /<br>
    //
    </td>
    <td><p><strong>乘(*):</strong> 如果两个输入都为整数, 则结果为整数; 否则结果为浮点数.</p>
      <p><strong>其他用途:</strong> 星号(*) 运算符也用于<a href="Functions.htm#VariadicCall">可变参数函数调用</a>.</p>
      <p id="divide"><strong>真除(/):</strong> 即使两个输入都是整数, 真除的结果也为浮点数. 例如, <code>3/2</code> 结果为 1.5 而不是 1, 而 <code>4/2</code> 结果为 2.0 而不是 2.</p>
      <p id="IntegerDivide"><strong>整数除法(//):</strong> 如果两个输入都是整数, 那么双斜杠运算符使用高效的整数除法. 例如, <code>5//3</code> 结果为 1 而 <code>5//-3</code> 结果为 -1. 如果任何一个输入为浮点格式, 则抛出 <a href="lib/Error.htm#TypeError">TypeError</a>. 有关取模, 请参阅 <a href="lib/Math.htm#Mod">Mod</a>.</p>
    <p><a href="#AssignOp">*= 和 /= 运算符</a>是用变量的值乘以或除以另一个值的一种简写形式. 例如, <code>Var*=2</code> 和 <code>Var:=Var*2</code> 会得到相同的结果(不过前者执行的更好).</p>
    <p>除数为零, 则导致抛出 <a href="lib/Error.htm#ZeroDivisionError">ZeroDivisionError</a>.</p></td>
  </tr>
  <tr id="AddSub">
    <td class="center bold">+<br>
    -</td>
    <td><p><strong>加(+)</strong> 和 <strong>减(-)</strong>. 在相关的注释中, <a href="#AssignOp"><strong>+=</strong> 和 <strong>-=</strong> 运算符</a>是变量增加或减少的一种简写形式. 例如, <code>Var+=2</code> 和 <code>Var:=Var+2</code> 会得到相同的结果(不过前者执行的更好). 类似地, 变量可以通过使用 <a href="#IncDec">Var++, Var--, ++Var 或 --Var</a> 来增加或减少 1.</p>
      <p><strong>其他用途:</strong> 如果 + 或 - 符号前面没有一个值(或生成值的子表达式), 则将其解释为<a href="#unary">一元运算符</a>.</p>
    </td>
  </tr>
  <tr id="bitshift">
    <td class="center bold">&lt;&lt;<br>
    &gt;&gt;<br>
    &gt;&gt;&gt;</td>
    <td>
      <p><strong>按位左移(&lt;&lt;)</strong>. 使用示例: <code>Value1 &lt;&lt; Value2</code>. 这相当于 <em>Value1</em> 乘以 "2 的 <em>Value2</em> 次幂".</p>
      <p><strong>算术位右移(&gt;&gt;)</strong>. 使用示例: <code>Value1 &gt;&gt; Value2</code>. 这相当于 <em>Value1</em> 除以 "2 的 <em>Value2</em> 次幂" 并将结果四舍五入到数轴左侧最接近的整数; 例如, <code>-3&gt;&gt;1</code> 结果为 -2.</p>
      <p><strong>逻辑位右移(&gt;&gt;&gt;)</strong>. 使用示例: <code>Value1 &gt;&gt;&gt; Value2</code>. 与算术位右移不同, 这并不保留数字的符号. 例如, -1 与无符号的 64 位整数 0xffffffffffffffff 拥有相同的位表示, 因此 <code>-1 &gt;&gt;&gt; 1</code> 结果为 0x7fffffffffffffff.</p>
      <p>下面的内容适用于这三个运算符:</p>
      <ul>
        <li>如果任何一个输入是浮点数, 则抛出 <a href="lib/Error.htm#TypeError">TypeError</a>.</li>
        <li>执行 64 位运算, 结果为 64 位有符号整数.</li>
        <li>如果 <em>Value2</em> 小于 0 或大于 63, 则抛出异常.</li>
      </ul>
    </td>
  </tr>
  <tr id="bitwise">
    <td class="center bold">&amp;<br>
    ^<br>
    |
    </td>
    <td>
      <p><strong>按位与(&amp;)</strong>, <strong>按位异或(^)</strong> 和 <strong>按位或(|)</strong>. 这三个运算符中, <strong>&amp;</strong> 优先级最高, 而 <strong>|</strong> 优先级最低.</p>
      <p>下面的内容适用于这三个运算符:</p>
      <ul>
        <li>如果其中一个输入是浮点数, 则抛出 <a href="lib/Error.htm#TypeError">TypeError</a>.</li>
        <li>执行 64 位运算, 结果为 64 位有符号整数.</li>
      </ul>
      <p>相关: <a href="#unary">按位非(~)</a></p>
    </td>
  </tr>
  <tr id="concat">
    <td class="center bold">.</td>
    <td>
      <p><strong>连接</strong>. 每边至少有一个空格或制表符的句点(点) 用于将两个项组合成单个字符串. 您还可以省略句点以获得相同的结果(除非有歧义, 如 <code>x <strong>-</strong>y</code>, 或者右边的项有一个前导的 ++ 或 --). 当省略点时, 要合并的项之间必须至少有一个空格或制表符.</p>
      <pre>Var := "The color is " <strong>.</strong> FoundColor  <em>; 显式连接</em>
Var := "The color is " FoundColor    <em>; 自动连接</em>
</pre>
      <p>还可以用来连接子表达式. 例如: <code>Var := "The net price is " <strong>.</strong>  Price * (1 - Discount/100)</code>.</p>
      <p>以句点(或其他任何运算符) 开始的行会自动<a href="Scripts.htm#continuation">附加到</a>上一行的末尾.</p>
      <p>每个输入的整个<a href="lib/StrLen.htm">长度</a>会被使用, 即使它包含二进制零. 例如, <code>Chr(0x2010) Chr(0x0000) Chr(0x4030)</code> 生成以下字节的字符串(由于 UTF-16-LE 编码): 0x10, 0x20, 0, 0, 0x30, 0x40. 结果有一个额外的空结束符(二进制零), 它不包含在长度中.</p>
      <p><strong>其他用途:</strong> 如果句点右侧没有空格或制表符, 则将其解释为原义<a href="#numbers">浮点数</a>或<a href="#objdot">成员访问</a>. 例如, <code>1.1</code> 和 <code>(.5)</code> 是数字, <code>A_Args.Has(3)</code> 方法调用, 而 <code>A_Args.Length</code> 是一个属性访问.</p>
    </td>
  </tr>
  <tr id="regex">
    <td class="center bold">~=</td>
    <td><a href="lib/RegExMatch.htm">RegExMatch</a> 的简写形式. 例如, <code>"abc123" ~= "\d"</code> 结果为 4(首个数字字符串的位置).</td>
  </tr>
  <tr id="compare">
    <td class="center bold">&gt;&nbsp;&nbsp;&nbsp;&lt;<br>
    &gt;= &lt;=</td>
    <td>
      <p><strong>大于(&gt;)</strong>, <strong>小于(&lt;)</strong>, <strong>大于或等于(&gt;=)</strong> 和 <strong>小于或等于(&lt;=)</strong>. 输入的数据是以数字方式进行比较的. 如果其中一个输入不是数字或数字字符串, 则抛出 <a href="lib/Error.htm#TypeError">TypeError</a>.</p>
    </td>
  </tr>
  <tr id="equal">
    <td class="center bold">=<br>
      ==<br>
      !=<br>
      !==</td>
    <td>
      <p><strong>不区分大小写的等号(=) / 不等号(!=)</strong> 和 <strong>区分大小写的等号(==) / 不等号(!==)</strong>. 运算符 <strong>==</strong> 的行为和 <strong>=</strong> 是一样的, 除非其中一个输入不是数字(或都是字符串), 在这种情况下 <strong>==</strong> 总是区分大小写的, 而 <strong>=</strong> 总是不区分大小写的. <strong>!=</strong> 和 <strong>!==</strong> 与其对应的没有 <strong>!</strong> 的运算符是一样的, 只是其结果取反.</p>
      <p><strong>==</strong> 和 <strong>!==</strong> 运算符可用于比较包含二进制零的字符串. 除了 <strong>~=</strong> 之外的所有其他比较运算符仅比较到第一个二进制零.</p>
      <p>对于不区分大小写的比较, 只有 ASCII 字母 A-Z 才会被认为等同于它们的小写字母. 如果要根据当前用户区域规则进行比较, 请使用 <a href="lib/StrCompare.htm">StrCompare</a> 并为 <em>CaseSense</em> 参数指定 "Locale".</p>
    </td>
  </tr>
  <tr>
    <td class="center bold">IS<br>IN<br>CONTAINS</td>
    <td id="is">
      <p>如果 <em>Value</em> 是 <em>Class</em> 的实例, 那么 <code><i>Value</i> <strong>is</strong> <i>Class</i></code> 结果为 1(true), 否则为 0(false). <em>Class</em> 必须是一个<a href="lib/Object.htm">对象</a>, 并具有自有 <a href="lib/Class.htm#Prototype">Prototype</a> 属性, 但通常该属性是由类定义隐式定义的. 这个操作一般等同于 <code>HasBase(<i>Value</i>, <i>Class</i>.Prototype)</code>.</p>
      <p><code id="in"><strong>in</strong></code> 和 <code id="contains"><strong>contains</strong></code> 保留给将来使用.</p>
    </td>
  </tr>
  <tr id="not">
    <td class="center bold">NOT</td>
    <td><strong>逻辑非</strong>. 除了优先级较低外, 其他的与 <strong>!</strong> 运算符相同. 例如, <code>not (x = 3 or y = 3)</code> 等同于 <code><strong>!</strong>(x = 3 or y = 3)</code>.</td>
  </tr>
    <tr id="and">
      <td class="center bold">AND<br>
      &amp;&amp;</td>
      <td><p>这两个运算符都是<strong>逻辑与</strong>. 例如: <code>x &gt; 3 and x &lt; 10</code>.</p>
        <p>在表达式中, 所有运算元都为 true, 则返回 <u>最后的</u> 运算元. 否则, 返回 <u>第一个</u> 为 false 的运算元. 换句话说, 只有当所有运算元都为 true 时, 结果才为 true. 布尔表达式需要进行<a href="Functions.htm#ShortCircuit">求值优化</a>(从左到右) 以提高性能.</p>
        <p>在下面的例子中, 所有运算元都为真, 并都要进行计算:</p>
        <pre>A := 1, B := {}, C := 20, D := true, E := "str"
MsgBox(A &amp;&amp; B &amp;&amp; C &amp;&amp; D &amp;&amp; E) <em>; 显示 "str"(E).</em></pre>
        <p>在下面的例子中, 因为 B 为假, 所以只计算前两个运算元. 其余部分被忽略, 即 C 不递增:</p>
        <pre>A := 1, B := "", C := 0, D := false, E := "str"
MsgBox(A &amp;&amp; B &amp;&amp; ++C &amp;&amp; D &amp;&amp; E) <em>; 显示 ""(B).</em></pre>
        <p>以 <code>AND</code> 或 <code>&amp;&amp;</code>(或其他任何运算符) 开始的行会自动<a href="Scripts.htm#continuation">附加到</a>上一行的末尾.</p></td>
    </tr>
    <tr id="or">
      <td class="center bold">OR<br>
      ||</td>
      <td><p>这两个运算符都是<strong>逻辑或</strong>. 例如: <code>x &lt;= 3 or x &gt;= 10</code>.</p>
        <p>在表达式中, 至少有一个运算元为 true, 则返回 <u>第一个</u> 为 true 的运算元. 否则, 返回 <u>最后一个</u> 为 false 的运算元. 换句话说, 只要有一个运算元为真, 结果就为真. 布尔表达式需要进行<a href="Functions.htm#ShortCircuit">求值优化</a>(从左到右) 以提高性能.</p>
        <p>在下面的示例中, 至少有一个运算元为真. 直到 D(包括) 的所有运算元都要进行计算. E 被忽略, 并始终不会自增:</p>
        <pre>A := "", B := false, C := 0, D := "str", E := 20
MsgBox(A || B || C || D || ++E) <em>; 显示 "str"(D).</em></pre>
        <p>在下面的例子中, 所有运算元都为假, 并都要进行计算:</p>
        <pre>A := "", B := false, C := 0
MsgBox(A || B || C) <em>; 显示 "0"(C).</em></pre>
        <p>以 <code>OR</code> 或 <code>||</code>(或其他任何运算符) 开始的行会自动<a href="Scripts.htm#continuation">附加到</a>上一行的末尾.</p></td>
    </tr>
  <tr id="or-maybe">
    <td class="center bold">??</td>
    <td>
      <p><strong>Or maybe</strong>, 也称为合并运算符. 如果左操作数(必须是一个变量) 有一个值, 它就成为结果, 并跳过右分支. 否则, 右操作数将成为结果. 换句话说, <code>A ?? B</code> 的行为类似于 <code>A || B</code> (<a href="#or">逻辑或</a>), 除了条件是 <code>IsSet(A)</code>.</p>
      <p>这通常用于在已知变量或可选参数可能还没有值时提供默认值. 例如:</p>
      <pre>MsgBox MyVar ?? "Default value"</pre>
      <p>由于期望变量有时<a href="Concepts.htm#uninitialized-variables">未初始化</a>, 因此在这种情况下不会抛出错误. 与 <code>IsSet(A) ? A : B</code> 不同的是, 如果变量有其他引用但没有赋值, <a href="lib/_Warn.htm#VarUnset">VarUnset 警告</a>仍然可以在加载时显示.</p>
    </td>
  </tr>
  <tr id="ternary">
    <td class="center bold">?:</td>
    <td>
      <p><strong>三元运算符</strong>. 此运算符是 <a href="lib/If.htm">if-else 语句</a>的简写形式. 它计算左侧的条件来决定两个分支中哪个作为最终结果. 例如, <code>var := x&gt;y ? 2 : 3</code>, 当 x 大于 y 时保存 2 到 <em>Var</em>; 否则保存 3. 为了提高性能, 只计算决定性的分支(请参阅<a href="Functions.htm#ShortCircuit">求值优化</a>).</p>
      <p>另请参阅: <a href="#maybe">maybe(<em>var</em>?)</a>, <a href="#or-maybe">or-maybe(??)</a></p>
      <p class="warning"><strong>注意:</strong> 当在行的开头使用时, 三元条件通常应该用括号括起来, 以减少与其他类型语句的歧义. 有关详情, 请参阅<a href="Language.htm#expression-statements">表达式语句</a>.</p>
    </td>
  </tr>
  <tr id="AssignOp">
    <td class="center bold">:=<br>
        +=<br>
        -=<br>
        *=<br>
        /=<br>
        //=<br>
        .=<br>
        |=<br>
        &amp;=<br>
        ^=<br>
        &gt;&gt;=<br>
        &lt;&lt;=<br>
        &gt;&gt;&gt;=
    </td>
    <td><p><strong>赋值</strong>. 对变量的内容进行运算, 然后把结果保存到同一个变量中. 最简单的赋值运算符为冒号等号(:=), 它把表达式的结果保存到变量中. 关于其他运算符的功能说明, 请参阅这个表格中它们的相关条目. 例如, <code>Var //= 2</code> 执行<a href="#IntegerDivide">整数除法</a>把 <em>Var</em> 除以 2, 然后把结果保存回 <em>Var</em>. 类似的, <code>Var <strong>.=</strong> "abc"</code> 为 <code>Var := Var <strong>.</strong> "abc"</code> 的一种简写形式.</p>
      <p>与其他大多数运算符不同, 赋值运算是从右往左执行的. 因此, <code>Var1 := Var2 := 0</code> 这个语句中首先把 0 赋值给 <em>Var2</em>, 然后把 <em>Var2</em> 赋值给 <em>Var1</em>.</p>
    <p>如果赋值作为某些其他运算符的输入, 它的值是变量本身. 例如, 如果 <em>Var</em> 的新增值大于 50, 表达式 <code>(Var+=2) &gt; 50</code> 为真. 将赋值与<a href="#ref">引用操作符</a>结合起来也是有效的, 如 <code>&amp;(Var := "initial value")</code>.</p>
    <p>需要避免语法错误或提供更直观的操作时, 会自动提升赋值运算符的优先级. 另外, <code class="no-highlight">x==y &amp;&amp; z:=1</code> 计算为 <code class="no-highlight">x==y &amp;&amp; (z:=1)</code>, 当 x 不等于 y 时进行<a href="Functions.htm#ShortCircuit">短路</a>计算. 例如: <code>not x:=y</code> 等同于 <code>not (x:=y)</code>. 类似的, <code>++Var := X</code> 等同于 <code>++(Var := X)</code>; 而 <code>Z&gt;0 ? X:=2 : Y:=2</code> 等同于 <code>Z&gt;0 ? (X:=2) : (Y:=2)</code>.</p>
    <p>目标变量可以通过将直接赋值(<code>:=</code>) 与 <code>unset</code> 关键字或 <a href="Variables.htm#maybe">maybe(<em>var</em>?)</a> 运算符联合使用来 <em>un-set</em>(取消设置). 例如: <code>Var := unset</code>, <code>Var1 := (Var2?)</code>.</p>
    <p>赋值还可以针对对象的属性, 如 <code>myArray.Length += n</code> 或 <code>myArray[i] .= t</code>. 当赋值给一个属性时, 子表达式的结果是赋值的值, 而不是变量引用.</p>
    </td>
  </tr>
  <tr id="fat-arrow">
    <td class="center"><strong>() =&gt;</strong> <em>expr</em></td>
    <td>
      <p><strong>胖箭头函数</strong>. 定义一个简单的<a href="Functions.htm">函数</a>并返回一个 <a href="lib/Func.htm">Func</a> 或<a href="Functions.htm#closures">闭包</a>对象. 将函数的<a href="Functions.htm#param">参数列表</a>(可以在前面加上函数名) 写在操作符的左边. 当函数被调用时(通过返回的引用), 它计算子表达式 <em>expr</em> 并返回结果.</p>
      <p>下面两个例子是等价的:</p>
      <pre>sumfn := Sum(a, b) =&gt; a + b</pre>
      <pre>Sum(a, b) {
    return a + b
}
sumfn := Sum</pre>
      <p>在这两种情况下, 函数都是在脚本启动时<strong>无条件</strong>定义的, 但是函数引用只有在赋值时才存储在 <em>sumfn</em> 中.</p>
      <p>如果函数名被省略, 而参数列表只包含一个参数名, 则可以省略圆括号. 下面的例子定义了一个带有一个参数 <code>a</code> 的匿名函数, 并将其引用存储在变量 <code>double</code> 中:</p>
      <pre>double := a =&gt; a * 2</pre>
      <p><em>expr</em> 中的变量引用的解析方法与完整函数定义中的方法相同. 例如, <em>expr</em> 可以引用 outer 函数的局部变量(就像在任何<a href="Functions.htm#nested">嵌套函数</a>中一样), 在这种情况下, 每当计算胖箭头表达式时, 都会创建一个新的<a href="Functions.htm#closures">闭包</a>并返回它. 因为不能使用声明, 所以该函数总是<a href="Functions.htm#AssumeLocal">假定-局部的</a>.</p>
      <p>为函数指定名称允许递归地调用它或由其他嵌套函数调用它, 而无需在其内部存储对<a href="Functions.htm#closures">闭包</a>的引用(从而创建有问题的<a href="Objects.htm#Circular_References">循环引用</a>). 它还有助于调试, 比如 <a href="lib/Func.htm#Name">Func.Name</a> 或显示在调试器的调用堆栈上.</p>
      <p>胖箭头语法也可以用来定义简写的<a href="Objects.htm#Custom_Classes_property_short">属性</a>和<a href="Objects.htm#Custom_Classes_method">方法</a>.</p>
    </td>

  </tr>
  <tr id="comma">
    <td class="center bold">,</td>
    <td><p><strong>逗号(多语句)</strong>. 逗号可以用来在单行中书写多个子表达式. 最常用于把多个赋值或函数调用聚集在一起. 例如: <code>x:=1<strong>,</strong> y+=2<strong>,</strong> ++index, MyFunc()</code>. 这样的语句按从左到右的顺序执行.</p>
      <p class="note"><strong>注意:</strong> 以逗号(或其他任何运算符) 开始的行会自动<a href="Scripts.htm#continuation">附加到</a>上一行的末尾. 另请参阅: <a href="#CommaPerf">逗号的性能</a>.</p>
      <p>逗号还用于分隔函数调用的或控制流语句的参数. 若要在参数列表中包含多语句表达式, 请用一组额外的圆括号将其括起来. 例如, <code>MyFn((x, y))</code> 计算 x 和 y, 但传递 y 作为 MyFn 的第一个也是唯一一个参数.</p>
      <p id="CommaPerf">与 AutoHotkey v1 相比, 逗号运算符的性能通常不如编写单独的表达式. 随着越来越多的表达式被组合成单个表达式, 性能不断降低; 例如, 将五个或十个简单表达式组合成一个表达式可能会慢 35&nbsp;%. 在组合函数调用时可能会出现例外.</p>
    </td>
  </tr>
</table>
<p>下面列出的子表达式类型覆盖计算的优先级/顺序:</p>
<table class="info">
  <tr>
    <th class="center">表达式</th>
    <th abbr="Descr">描述</th>
  </tr>
  <tr>
    <td class="center"><strong>(</strong><em>表达式</em><strong>)</strong></td>
    <td>
      <p>括号中包含的任何子表达式. 例如, <code>(3 + 2) * 2</code> 强制首先计算 <code>3 + 2</code>.</p>
      <p>对于多语句表达式, 将返回 <u>最后</u> 一条语句的结果. 例如, <code>(a := 1, b := 2, c := 3)</code> 返回 3.</p>
    </td>
  </tr>
  <tr>
     <td class="center"><p>Mod<strong>()</strong><br>
        Round<strong>()</strong><br>
    Abs<strong>()</strong></p></td>
    <td rowspan="2"><p><strong>函数调用</strong>. 在函数名称或表达式与参数列表开头的左圆括号之间不能有空格. 有关详情, 请参阅<a href="Language.htm#function-calls">函数调用</a>.</p>
    <p><em>(表达式)</em> 不一定要用括号括起来, 但这样做可以消除歧义. 例如, <code>(x.y)()</code> 从一个属性中检索一个函数, 然后没有参数调用它, 而 <code>x.y()</code> 将隐式地传递 <code>x</code> 作为第一个参数.</p>
      </td>
  </tr>
  <tr>
    <td class="center" style="white-space: nowrap;"><p><em>(expression)</em><strong>()</strong></p></td>
  </tr>
  <tr>
    <td class="center">Fn(<strong><em>Params</em>*</strong>)</td>
    <td><p><a href="Functions.htm#VariadicCall">可变参数函数调用</a>. <em>Params</em> 是一个可枚举的对象(具有 <a href="Objects.htm#__Enum">__Enum</a> 方法的对象), 例如包含参数值的<a href="lib/Array.htm">数组</a>.</p></td>
  </tr>
  <tr id="square-brackets">
    <td class="center"><strong>x[y]<br>[a, b, c]</strong></td>
    <td>
      <p><strong>项目访问</strong>. 使用参数 <em>y</em>(或代替 <em>y</em> 的多个参数) 获取或设置对象 <em>x</em> 的 <a href="Objects.htm#__Item">__Item</a> 属性(或默认属性). 这通常对应于集合中的数组元素或项目, 其中 <em>y</em> 是项目的索引或键. 项目可以在右方括号后使用任何<a href="#AssignOp">赋值运算符</a>来赋值. 例如, <code>x[y] := z</code>.</p>
      <p><strong>数组标识符</strong>(数组字面量). 如果左方括号前面没有值(或者一个产生值的子表达式), 它被解释为一个数组的开始. 例如, <code>[a, b, c]</code> 等同于 <code>Array(a, b, c)</code>(a, b 和 c 都是变量).</p>
      <p>有关常见用法, 请参阅<a href="Objects.htm#Usage_Simple_Arrays">数组</a>和 <a href="Objects.htm#Usage_Associative_Arrays">Map</a>(映射).</p>
    </td>
  </tr>
  <tr id="curly-braces">
    <td class="center"><strong>{a: b, c: d}</strong></td>
    <td>
      <p><strong>对象标识符</strong>(对象字面量). 创建一个<a href="lib/Object.htm">对象</a>. 其中的每一对项目由一个原义的属性名称 <code>a</code> 和一个属性值表达式 <code>b</code> 组成. 例如, <code>x := {a: b}</code> 等同于 <code>x := Object(), x.a := b</code>. 可以在对象文本中设置 <a href="lib/Object.htm#Base">Base</a>, 但是所有其他属性都设置为 <em>自有的属性</em>, 可能会覆盖从基对象继承的属性.</p>
      <p>要使用动态属性名, 请将子表达式用百分号括起来. 例如: <code>{%nameVar%: valueVar}</code>.</p>
    </td>
  </tr>
</table>

<h2 id="BuiltIn">内置变量</h2>
<p>下面的变量被内置到程序中, 可以被任何脚本引用.</p>
<p class="note">有关一般信息, 请参阅<a href="Concepts.htm#built-in-variables">内置变量</a>.</p>
<h3 id="BuiltIn_TOC">目录</h3>
<ul>
  <li>特殊字符: <a href="#Space">A_Space</a>, <a href="#Tab">A_Tab</a></li>
  <li>脚本属性: <a href="#Args">命令行参数</a>, <a href="#WorkingDir">A_WorkingDir</a>, <a href="#ScriptDir">A_ScriptDir</a>, <a href="#ScriptName">A_ScriptName</a>, <a href="#prop">(...更多...)</a></li>
  <li>日期和时间: <a href="#YYYY">A_YYYY</a>, <a href="#MM">A_MM</a>, <a href="#DD">A_DD</a>, <a href="#Hour">A_Hour</a>, <a href="#Min">A_Min</a>, <a href="#Sec">A_Sec</a>, <a href="#date">(...更多...)</a></li>
  <li>脚本设置: <a href="#IsSuspended">A_IsSuspended</a>, <a href="#ListLines">A_ListLines</a>, <a href="#TitleMatchMode">A_TitleMatchMode</a>, <a href="#settings">(...更多...)</a></li>
  <li>用户空闲时间: <a href="#TimeIdle">A_TimeIdle</a>, <a href="#TimeIdlePhysical">A_TimeIdlePhysical</a>, <a href="#TimeIdleKeyboard">A_TimeIdleKeyboard</a>, <a href="#TimeIdleMouse">A_TimeIdleMouse</a></li>
  <li>热键, 热字串和自定义菜单项: <a href="#ThisHotkey">A_ThisHotkey</a>, <a href="#EndChar">A_EndChar</a>, <a href="#h">(...更多...)</a></li>
  <li>操作系统和用户信息: <a href="#OSVersion">A_OSVersion</a>, <a href="#Screen">A_ScreenWidth</a>, <a href="#Screen">A_ScreenHeight</a>, <a href="#os">(...更多...)</a></li>
  <li>杂项: <a href="#Clipboard">A_Clipboard</a>, <a href="#Cursor">A_Cursor</a>, <a href="#EventInfo">A_EventInfo</a>, <a href="#misc">(...更多...)</li>
  <li>Loop: <a href="#Index">A_Index</a>, <a href="#loop">(...更多...)</a></li>
</ul>
<h3 id="Special_Characters">特殊字符</h3>
<table class="info">
  <tr>
    <th abbr="Var">变量</th>
    <th abbr="Descr">描述</th>
  </tr>
  <tr id="Space">
    <td>A_Space</td>
    <td>包含单个空格字符.</td>
  </tr>
  <tr id="Tab">
    <td>A_Tab</td>
    <td>包含单个 tab(制表符) 字符.</td>
  </tr>
</table>
<h3 id="prop">脚本属性</h3>
<table class="info">
  <tr>
    <th abbr="Var">变量</th>
    <th abbr="Descr">描述</th>
  </tr>
  <tr id="Args">
    <td>A_Args</td>
    <td>包含一个命令行参数<a href="Objects.htm#Usage_Simple_Arrays">数组</a>. 有关详情, 请参阅<a href="Scripts.htm#cmd">向脚本传递命令行参数</a>.</td>
  </tr>
  <tr id="WorkingDir">
    <td>A_WorkingDir</td>
    <td><p>可以用来获取或设置脚本当前工作目录, 这是访问文件的默认路径. 除非是根目录, 否则不包含路径末尾的反斜杠. 两个示例: C:\ 和 C:\My Documents.</p>
    <p><a href="lib/SetWorkingDir.htm">SetWorkingDir</a> 也可以用来改变工作目录.</p>
    <p>无论脚本是如何启动的, 脚本的工作目录默认为 <a href="#ScriptDir">A_ScriptDir</a>.</p></td>
  </tr>
  <tr id="InitialWorkingDir">
    <td>A_InitialWorkingDir</td>
    <td>脚本的初始工作目录, 由它的启动方式决定. 例如, 如果它是通过快捷方式运行的 -- 比如在开始菜单 -- 它的初始工作目录是由快捷方式属性中的 "起始位置" 字段决定的.</td>
  </tr>
  <tr id="ScriptDir">
    <td>A_ScriptDir</td>
    <td>
      <p>当前脚本所在目录的完整路径. 不包含最后的反斜杠(根目录同样如此).</p>
      <p>如果脚本文字是从<a href="Scripts.htm#stdin">标准输入中读取的</a>而不是从文件中读取的, 变量值为<a href="#InitialWorkingDir">初始工作目录</a>.</p></td>
  </tr>
  <tr id="ScriptName">
    <td>A_ScriptName</td>
    <td>
      <p>可用于获取或设置 <a href="lib/MsgBox.htm">MsgBox</a>, <a href="lib/InputBox.htm">InputBox</a>, <a href="lib/FileSelect.htm">FileSelect</a>, <a href="lib/DirSelect.htm">DirSelect</a> 和 <a href="lib/Gui.htm">Gui</a> 的默认标题. 如果脚本没有设置, 则默认为当前脚本的文件名, 不包括路径, 例如 MyScript.ahk.</p>
      <p>如果<a href="Scripts.htm#stdin">从标准输入中读取</a>而不是从文件中读取的脚本文本, 则该变量包含一个星号(*).</p>
      <p>如果脚本是<a href="Scripts.htm#ahk2exe">编译的</a>或<a href="Program.htm#embedded-scripts">嵌入的</a>, 这就是当前可执行文件的名称.</p>
    </td>
  </tr>
  <tr id="ScriptFullPath">
    <td>A_ScriptFullPath</td>
    <td>
      <p>当前脚本的完整路径, 例如 C:\Scripts\My Script.ahk</p>
      <p>如果脚本文字是从<a href="Scripts.htm#stdin">标准输入中读取的</a>而不是从文件中读取的, this variable contains an asterisk (*).</p>
      <p>如果脚本是<a href="Scripts.htm#ahk2exe">编译的</a>或<a href="Program.htm#embedded-scripts">嵌入的</a>, 这就是当前可执行文件的完整路径.</p>
    </td>
  </tr>
  <tr id="ScriptHwnd">
    <td>A_ScriptHwnd</td>
    <td>脚本的<a href="Program.htm#main-window">主窗口</a>(隐藏的) 的唯一 ID(HWND/句柄).</td>
  </tr>
  <tr id="LineNumber">
    <td>A_LineNumber</td>
    <td><p>脚本(或其 <a href="lib/_Include.htm">#Include 文件</a>) 中正在执行的行的行号. 这个行号与 <a href="lib/ListLines.htm">ListLines</a> 显示的一致; 它对于错误报告非常有用, 比如这个例子: <code>MsgBox "Could not write to log file (line number " A_LineNumber ")"</code>.</p>
    <p>由于<a href="Scripts.htm#ahk2exe">已编译脚本</a>已经把它所有的 <a href="lib/_Include.htm">#Include 文件</a>合并成一个大脚本, 所以它的行号可能与它在未编译模式运行时不一样.</p></td>
  </tr>
  <tr id="LineFile">
    <td>A_LineFile</td>
    <td>
      <p><a href="#LineNumber">A_LineNumber</a> 所属文件的完整路径和名称. 如果脚本是从外部文件加载的, 这等同于 <a href="#ScriptFullPath">A_ScriptFullPath</a>, 除非该行属于脚本的 <a href="lib/_Include.htm">#Include 文件</a>之一.</p>
      <p>如果脚本是基于一个 <a href="Scripts.htm#ahk2exe-base">.bin 文件</a><a href="Scripts.htm#ahk2exe">编译的</a>, 这就是当前可执行文件的完整路径和名称, 等同于 <a href="#ScriptFullPath">A_ScriptFullPath</a>.</p>
      <p>如果脚本是<a href="Program.htm#embedded-scripts">嵌入的</a>, A_LineFile 包含一个星号(*) 后面是资源名称; 例如 *#1</p>
  </tr>
  <tr id="ThisFunc">
    <td>A_ThisFunc</td>
    <td>当前正在执行的<a href="Functions.htm">自定义函数</a>的名称(没有则为空); 例如: MyFunction. 另请参阅: <a href="lib/Func.htm#Name">Name 属性(Func)</a></td>
  </tr>
  <tr id="AhkVersion">
    <td>A_AhkVersion</td>
    <td>包含了运行当前脚本的 AutoHotkey 主程序的版本号, 例如 1.0.22. 在<a href="Scripts.htm#ahk2exe">已编译脚本</a>中, 它包含了原来编译时使用的主程序的版本号. 格式化的版本号使得脚本可以使用 &gt; 或 &gt;= 来检查 A_AhkVersion 是否大于某个最小的版本号, 如这个例子所示: <code>if (A_AhkVersion &gt;= "1.0.25.07")</code>.</td>
  </tr>
  <tr id="AhkPath">
    <td>A_AhkPath</td>
    <td>
      <p>对于非编译的或<a href="Program.htm#embedded-scripts">嵌入的</a>脚本: 实际运行当前脚本的 EXE 文件的完整路径和名称. 例如: C:\Program Files\AutoHotkey\AutoHotkey.exe</p>
      <p>对于基于 <a href="Scripts.htm#ahk2exe-base">.bin 文件</a>的<a href="Scripts.htm#ahk2exe">编译脚本</a>, 该值是通过从注册表中读取安装目录并附加 "\AutoHotkey.exe" 来确定的. 如果没有安装 AutoHotkey, 该值为空. 等同于下面的例子:</p>
      <pre>InstallDir := RegRead("HKLM\SOFTWARE\AutoHotkey", "InstallDir", "")
AhkPath := InstallDir ? InstallDir "\AutoHotkey.exe" : ""</pre>
      <p>对于基于 .exe 文件的编译脚本, A_AhkPath 包含编译脚本的完整路径. 这可以与 <a href="Scripts.htm#SlashScript">/script</a> 结合使用来执行外部脚本. 如果要找到已安装的 AutoHotkey 副本, 请按上面所示读取注册表.</p>
    </td>
  </tr>
  <tr id="IsCompiled">
    <td>A_IsCompiled</td>
    <td>如果当前运行的脚本为<a href="Scripts.htm#ahk2exe">已编译 EXE</a> 时, 此变量值为 1, 否则为 0(这会被视为 <a href="#Boolean">false</a>).</td>
  </tr>
</table>
<h3 id="date">日期和时间</h3>
<table class="info">
  <tr>
    <th abbr="Var">变量</th>
    <th abbr="Descr">描述</th>
  </tr>
  <tr id="YYYY">
    <td>A_YYYY</td>
    <td>
      <p>4 位数表示的当前年份(例如 2004). 与 A_Year 含义相同.</p>
      <p class="note"><strong>注意:</strong> 要检索符合您区域设置和语言的格式化时间或日期, 请使用 <code><a href="lib/FormatTime.htm">FormatTime</a>()</code>(时间和长日期) 或 <code><a href="lib/FormatTime.htm">FormatTime</a>(, "LongDate")</code>(检索长格式日期).</p>
    </td>
  </tr>
  <tr id="MM">
    <td>A_MM</td>
    <td>2 位数表示的当前月份(01-12). 与 A_Mon 含义相同.</td>
  </tr>
  <tr id="DD">
    <td>A_DD</td>
    <td>2 位数表示的当前月份的日期(01-31). 与 A_MDay 含义相同.</td>
  </tr>
  <tr id="MMMM">
    <td>A_MMMM</td>
    <td>使用当前用户语言表示的当前月份的全称, 例如 July</td>
  </tr>
  <tr id="MMM">
    <td>A_MMM</td>
    <td>使用当前用户语言表示的当前月份的简称, 例如 Jul</td>
  </tr>
  <tr id="DDDD">
    <td>A_DDDD</td>
    <td>使用当前用户语言表示的当前星期几的全称, 例如, Sunday</td>
  </tr>
  <tr id="DDD">
    <td>A_DDD</td>
    <td>使用当前用户语言表示的当前星期几的简称, 例如 Sun</td>
  </tr>
  <tr id="WDay">
    <td>A_WDay</td>
    <td>1 位数表示的当前星期经过的天数(1-7). 在所有区域设置中 1 都表示星期天.</td>
  </tr>
  <tr id="YDay">
    <td>A_YDay</td>
    <td>当前年份中经过的天数(1-366). 不会使用零对变量的值进行填充, 例如检索到 9, 而不是 009. 要检索零填充的值, 请使用: <code><a href="lib/FormatTime.htm">FormatTime</a>(, "YDay0")</code>.</td>
  </tr>
  <tr id="YWeek">
    <td>A_YWeek</td>
    <td>符合 ISO 8601 标准的当前的年份和周数(例如 200453). 要分离年份和周数, 请使用 <code>Year := <a href="lib/SubStr.htm">SubStr</a>(A_YWeek, 1, 4)</code> 和 <code>Week := <a href="lib/SubStr.htm">SubStr</a>(A_YWeek, -2)</code>. A_YWeek 的准确定义为: 如果含有 1 月 1 日的星期内有四天或四天以上在新年里, 则它被认为是新年的第一个星期. 否则, 它为前一年的最后一个星期, 而下一星期为新年的第一个星期.</td>
  </tr>
  <tr id="Hour">
    <td>A_Hour</td>
    <td>在 24 小时制(例如, 17 表示 5pm) 中 2 位数表示的当前小时数(00-23). 要获取带 AM/PM 提示的 12 小时制的时间, 请参照此例: <code><a href="lib/FormatTime.htm">FormatTime</a>(, "h:mm:ss tt")</code></td>
  </tr>
  <tr id="Min">
    <td>A_Min</td>
    <td><p>2 位数表示的当前分钟数(00-59).</p></td>
  </tr>
  <tr id="Sec">
    <td>A_Sec</td>
    <td>2 位数表示的当前秒数(00-59).</td>
  </tr>
  <tr id="MSec">
    <td>A_MSec</td>
    <td>3 位数表示的当前毫秒数(000-999). 要移除前导零, 请参照此例: <code>Milliseconds := A_MSec + 0</code>.</td>
  </tr>
  <tr id="Now">
    <td>A_Now</td>
    <td>
      <p>以 <a href="lib/FileSetTime.htm#YYYYMMDD">YYYYMMDDHH24MISS</a> 格式表示的当前本地时间.</p>
      <p class="note"><strong>注意:</strong> 可以使用 <a href="lib/DateAdd.htm">DateAdd</a> 和 <a href="lib/DateDiff.htm">DateDiff</a> 执行日期和时间的数学运算. 此外, <a href="lib/FormatTime.htm">FormatTime</a> 可以根据您的区域设置或选项来格式化日期和/或时间.</p>
    </td>
  </tr>
  <tr id="NowUTC">
    <td>A_NowUTC</td>
    <td>以 <a href="lib/FileSetTime.htm#YYYYMMDD">YYYYMMDDHH24MISS</a> 格式表示的当前的协调世界时(UTC). UTC 本质上和格林威治标准时间(GMT) 一致.</td>
  </tr>
  <tr id="TickCount">
    <td>A_TickCount</td>
    <td><p>计算机自启动以来经过的毫秒数, 最多为 49.7 天. 通过把 A_TickCount 保存到变量中, 经过一段时间后从最近的 A_TickCount 值中减去那个变量, 可以计算出所经过的时间. 例如:</p>
        <pre>StartTime := A_TickCount
Sleep 1000
ElapsedTime := A_TickCount - StartTime
MsgBox ElapsedTime " milliseconds have elapsed."</pre>
<p>如果您需要比 A_TickCount 的 10&nbsp;ms 更高的精确度, 请使用 <a href="lib/DllCall.htm#ExQPC">QueryPerformanceCounter()</a>(一个高精度计时器).</p>
</td>
  </tr>
</table>
<h3 id="settings">脚本设置</h3>
<table class="info">
  <tr>
    <th abbr="Var">变量</th>
    <th abbr="Descr">描述</th>
  </tr>
  <tr id="IsSuspended">
    <td>A_IsSuspended</td>
    <td>如果脚本<a href="lib/Suspend.htm">挂起</a>时值为 1, 否则为 0.</td>
  </tr>
  <tr id="IsPaused">
    <td>A_IsPaused</td>
    <td>如果在当前线程之后的<a href="misc/Threads.htm">线程</a>是<a href="lib/Pause.htm">暂停</a>时值为 1, 否则为 0.</td>
  </tr>
  <tr id="IsCritical">
    <td>A_IsCritical</td>
    <td>如果<a href="misc/Threads.htm">当前线程</a>的 <a href="lib/Critical.htm">Critical</a> 关闭时, 则值为 0. 否则值为大于零的整数, 即为 Critical 使用的<a href="lib/Critical.htm#Interval">消息检查间隔</a>. Critical 的当前状态可以通过 <code>Old_IsCritical := A_IsCritical</code> 然后是 <code>Critical Old_IsCritical</code> 来保存和恢复.</td>
  </tr>
  <tr id="ListLines">
    <td>A_ListLines</td>
    <td>可用于获取或设置是否记录行. 可能的值是 0(禁用) 和 1(启用). 有关详情, 请参阅 <a href="lib/ListLines.htm">ListLines</a>.</td>
  </tr>
  <tr id="TitleMatchMode">
    <td>A_TitleMatchMode</td>
    <td>可用于获取或设置标题匹配模式. 可能的值是 1, 2, 3 和 RegEx. 有关详情, 请参阅 <a href="lib/SetTitleMatchMode.htm">SetTitleMatchMode</a>.</td>
  </tr>
  <tr id="TitleMatchModeSpeed">
    <td>A_TitleMatchModeSpeed</td>
    <td>可用于获取或设置标题匹配速度. 可能的值是 fast 和 slow. 有关详情, 请参阅 <a href="lib/SetTitleMatchMode.htm">SetTitleMatchMode</a>.</td>
  </tr>
  <tr id="DetectHiddenWindows">
    <td>A_DetectHiddenWindows</td>
    <td>可用于获取或设置是否检测隐藏窗口. 可能的值是 0(禁止) 和 1(启用). 有关详情, 请参阅 <a href="lib/DetectHiddenWindows.htm">DetectHiddenWindows</a>.</td>
  </tr>
  <tr id="DetectHiddenText">
    <td>A_DetectHiddenText</td>
    <td>可以用来获取或设置是否检测窗口中的隐藏文本. 可能的值是 0(禁止) 和 1(启用). 有关详情, 请参阅 <a href="lib/DetectHiddenText.htm">DetectHiddenText</a>.</td>
  </tr>
  <tr id="FileEncoding">
    <td>A_FileEncoding</td>
    <td>可以用来获取或设置各种内置函数的默认编码. 有关详情, 请参阅 <a href="lib/FileEncoding.htm">FileEncoding</a>.</td>
  </tr>
  <tr id="SendMode">
    <td>A_SendMode</td>
    <td>可用于获取或设置发送模式. 可能的值是 Event, Input, Play 和 InputThenPlay. 有关详情, 请参阅 <a href="lib/SendMode.htm">SendMode</a>.</td>
  </tr>
  <tr id="SendLevel">
    <td>A_SendLevel</td>
    <td>可用于获取或设置发送级别, 为 0 至 100 之间的整数, 包括 0 和 100. 有关详情, 请参阅 <a href="lib/SendLevel.htm">SendLevel</a>.</td>
  </tr>
  <tr id="StoreCapsLockMode">
    <td>A_StoreCapsLockMode</td>
    <td>可以用来获取或设置是否在 <a href="lib/Send.htm">Send</a> 后恢复 <kbd>CapsLock</kbd> 的状态. 可能的值是 0(禁止) 和 1(启用). 有关详情, 请参阅 <a href="lib/SetStoreCapslockMode.htm">SetStoreCapsLockMode</a>.</td>
  </tr>
  <tr id="KeyDelay">
    <td>A_KeyDelay<br>
    A_KeyDuration</td>
    <td>可以用来获取或设置按键的延迟或持续时间, 单位为毫秒. 有关详情, 请参阅 <a href="lib/SetKeyDelay.htm">SetKeyDelay</a>.</td>
  </tr>
  <tr id="KeyDelayPlay">
    <td>A_KeyDelayPlay<br>
    A_KeyDurationPlay</td>
    <td>可以用来获取或设置通过 <a href="lib/Send.htm#SendPlayDetail">SendPlay</a> 模式发送的按键的延迟或持续时间, 单位为毫秒. 有关详情, 请参阅 <a href="lib/SetKeyDelay.htm">SetKeyDelay</a>.</td>
  </tr>
  <tr id="WinDelay">
    <td>A_WinDelay</td>
    <td>可用于获取或设置窗口函数的延迟, 单位为毫秒. 有关详情, 请参阅 <a href="lib/SetWinDelay.htm">SetWinDelay</a>.</td>
  </tr>
  <tr id="ControlDelay">
    <td>A_ControlDelay</td>
    <td>可用于获取或设置控件修改函数的延迟, 单位为毫秒. 有关详情, 请参阅 <a href="lib/SetControlDelay.htm">SetControlDelay</a>.</td>
  </tr>
  <tr id="MenuMaskKey">
    <td>A_MenuMaskKey</td>
    <td>控制哪个键被用来掩饰(屏蔽) Win 或 Alt 键松开事件. 有关详情, 请参阅 <a href="lib/A_MenuMaskKey.htm">A_MenuMaskKey</a>.</td>
  </tr>
  <tr id="MouseDelay">
    <td>A_MouseDelay<br>
    A_MouseDelayPlay</td>
    <td>可以用来获取或设置鼠标延迟, 单位为毫秒. 传统的 SendEvent 模式为 A_MouseDelay, 而 <a href="lib/Send.htm#SendPlayDetail">SendPlay</a> 为 A_MouseDelayPlay. 有关详情, 请参阅 <a href="lib/SetMouseDelay.htm">SetMouseDelay</a>.</td>
  </tr>
  <tr id="DefaultMouseSpeed">
    <td>A_DefaultMouseSpeed</td>
    <td>可以用来获取或设置默认的鼠标速度, 从 0(最快) 到 100(最慢) 的整数. 有关详情, 请参阅 <a href="lib/SetDefaultMouseSpeed.htm">SetDefaultMouseSpeed</a>.</td>
  </tr>
  <tr id="CoordMode">
    <td>A_CoordModeToolTip<br>
    A_CoordModePixel<br>
    A_CoordModeMouse<br>
    A_CoordModeCaret<br>
    A_CoordModeMenu</td>
    <td>可以用来获取或设置相对坐标的区域. 可能的值是 Window, Client 或 Screen. 有关详情, 请参阅 <a href="lib/CoordMode.htm">CoordMode</a>.</td>
  </tr>
  <tr id="RegView">
    <td>A_RegView</td>
    <td>可用于获取或设置注册表视图. 可能的值是 32, 64 和 Default. 有关详情, 请参阅 <a href="lib/SetRegView.htm">SetRegView</a>.</td>
  </tr>
  <tr id="TrayMenu">
    <td>A_TrayMenu</td>
    <td><p>返回可用于修改或显示托盘菜单的<a href="lib/Menu.htm">菜单对象</a>.</p></td>
  </tr>
  <tr id="AllowMainWindow">
    <td>A_AllowMainWindow</td>
    <td>
    <p>可以用来获取或设置是否允许通过<a href="Program.htm#tray-icon">托盘图标</a>打开脚本的<a href="Program.htm#main-window">主窗口</a>. 可能的值是 0(禁止) 和 1(允许).</p>
    <p>如果脚本既不是<a href="Scripts.htm#ahk2exe">编译的</a>也不是<a href="Program.htm#embedded-scripts">嵌入的</a>, 此变量默认为 1, 否则此变量默认为 0, 但可以通过给该变量赋值来改写它. 将其设置为 1 还可以恢复托盘菜单中的 "Open" 菜单项, 并启用主窗口的 View 菜单中的项目, 如 "Lines most recently executed", 这允许查看脚本的源代码和其他信息.</p>
    <p>在脚本运行时遇到下列函数, 总是能够显示主窗口并选择相应的视图选项: <a href="lib/ListLines.htm">ListLines</a>, <a href="lib/ListVars.htm">ListVars</a>, <a href="lib/ListHotkeys.htm">ListHotkeys</a> 和 <a href="lib/KeyHistory.htm">KeyHistory</a>.</p>
    <p>设置为 1 并不妨碍主窗口被 <a href="lib/WinShow.htm">WinShow</a> 显示, 或者被 <a href="lib/ControlGetText.htm">ControlGetText</a> 或类似的方法检查, 但它确实阻止了脚本的源代码和其他信息通过主窗口暴露出来, 除非脚本调用了上述的某个函数.</p></td>
  </tr>
  <tr id="IconHidden">
    <td>A_IconHidden</td>
    <td>可以用来获取或设置是否隐藏<a href="Program.htm#tray-icon">托盘图标</a>. 可能的值是 0(可见) 和 1(隐藏). 有关详情, 请参阅 <a href="lib/_NoTrayIcon.htm">#NoTrayIcon</a>.</td>
  </tr>
  <tr id="IconTip">
    <td>A_IconTip</td>
    <td><p>可用于获取或设置<a href="Program.htm#tray-icon">托盘图标</a>的工具提示文字, 当鼠标悬停在其上时显示该文本. 如果为空, 则使用脚本的名称.</p>
    <p>要创建多行工具提示, 请在每行之间使用换行符(`n), 例如 <code>"Line1`nLine2"</code>. 只显示前 127 个字符, 并且文本在第一个制表符(如果存在) 处被截断.</p>
    <p>在 Windows 10 及更早版本中, 若要显示包含 & 符号的工具提示文本, 请使用另外两个 & 符号来转义 & 符号. 例如, 指定 <code>A &amp;&amp;&amp; B</code> 将在工具提示的文本中显示 "A &amp; B".</p></td>
  </tr>
  <tr id="IconFile">
    <td>A_IconFile</td>
    <td>如果通过 <a href="lib/TraySetIcon.htm">TraySetIcon</a> 指定自定义的<a href="Program.htm#tray-icon">托盘图标</a>时, 变量的值为图标文件的完整路径和名称, 否则为空.</td>
  </tr>
  <tr id="IconNumber">
    <td>A_IconNumber</td>
    <td>如果 A_IconFile 为空时, 值为空. 否则, 它的值为 A_IconFile 中的图标的编号(通常为 1).</td>
  </tr>
</table>
<h3 id="User_Idle_Time">用户空闲时间</h3>
<table class="info">
  <tr>
    <th abbr="Var">变量</th>
    <th abbr="Descr">描述</th>
  </tr>
  <tr id="TimeIdle">
    <td>A_TimeIdle</td>
    <td>
    <p>从系统最后一次接收到键盘, 鼠标或其他输入后所经过的毫秒数. 这可以用来判断用户是否离开. 用户的物理输入和由 <strong>任何</strong> 程序或脚本生成的模拟输入(例如 <a href="lib/Send.htm">Send</a> 或 <a href="lib/MouseMove.htm">MouseMove</a> 函数) 会让此变量重置为零. 由于此变量的值趋向于以 10 的增量增加, 所以不应该判断它是否等于另一个值. 相反, 应该检查此变量是否大于或小于另一个值. 例如:</p>
    <pre>if A_TimeIdle &gt; 600000
    MsgBox "The last keyboard or mouse activity was at least 10 minutes ago."</pre>
     </td>
  </tr>
  <tr id="TimeIdlePhysical">
    <td>A_TimeIdlePhysical</td>
    <td>与上面类似, 但在安装了相应的钩子(<a href="lib/InstallKeybdHook.htm">键盘</a>或<a href="lib/InstallMouseHook.htm">鼠标</a>) 后会忽略模拟的键击和/或鼠标点击; 即此变量仅对物理事件做出响应. (这样避免了由于模拟键击和鼠标点击而误以为用户存在.) 如果两种钩子都没有安装, 则此变量等同于 A_TimeIdle. 如果仅安装了一种钩子, 那么仅此类型的物理输入才会对 A_TimeIdlePhysical 起作用(另一种/未安装钩子的输入, 包括物理的和模拟的, 都会被忽略).</td>
  </tr>
  <tr id="TimeIdleKeyboard">
    <td>A_TimeIdleKeyboard</td>
    <td>如果安装了<a href="lib/InstallKeybdHook.htm">键盘钩子</a>, 这是自系统上次接收物理键盘输入以来所经过的毫秒数. 否则, 这个变量就等于 A_TimeIdle.</td>
  </tr>
  <tr id="TimeIdleMouse">
    <td>A_TimeIdleMouse</td>
    <td>如果安装了<a href="lib/InstallMouseHook.htm">鼠标钩子</a>, 这是自系统上次收到物理鼠标输入以来所经过的毫秒数. 否则, 这个变量就等于 A_TimeIdle.</td>
  </tr>
</table>
<h3 id="h">热键, 热字串和自定义菜单项</h3>
<table class="info">
  <tr>
    <th abbr="Var">变量</th>
    <th abbr="Descr">描述</th>
  </tr>
  <tr id="ThisHotkey">
    <td>A_ThisHotkey</td>
    <td><p>最近执行的<a href="Hotkeys.htm">热键</a>或<a href="Hotstrings.htm">非自动替换热字串</a>(如果没有则为空), 例如 #z. 如果<a href="misc/Threads.htm">当前线程</a>被其他热键或热字串中断, 那么此变量的值会变化, 所以一般情况下, 最好使用 <a href="Hotkeys.htm#ThisHotkey">ThisHotkey</a> 参数.</p>
      <p>首次创建热键时 -- 通过 <a href="lib/Hotkey.htm">Hotkey 函数</a>或脚本中的<a href="Hotkeys.htm">双冒号语法</a> -- 其键名及其修饰符的顺序成为此热键的固定名称, 由热键的所有<a href="lib/_HotIf.htm#variant">变体</a>共享.</p>
      <p>首次创建热字串时 -- 通过 <a href="lib/Hotstring.htm">Hotstring 函数</a>或脚本中的<a href="Hotstring.htm">双冒号标签</a> -- 它的触发字符串和选项字符序列成为该热字符串的永久名称.</p>
    </td>
  </tr>
  <tr id="PriorHotkey">
    <td>A_PriorHotkey</td>
    <td>除了保存前一次热键的名称外, 其他的与上面相同. 如果没有它会为空.</td>
  </tr>
  <tr id="PriorKey">
    <td>A_PriorKey</td>
    <td>在最近一次键-按下或键-释放之前按下的最后一个键的名称, 如果在按键历史中找不到合适的键-按下则为空. 不包括由 AutoHotkey 脚本生成的所有输入. 要使用此变量, 首先必须安装<a href="lib/InstallKeybdHook.htm">键盘</a>或<a href="lib/InstallMouseHook.htm">鼠标钩子</a>并且启用了<a href="lib/KeyHistory.htm">key history(按键历史)</a>.</td>
  </tr>
  <tr id="TimeSinceThisHotkey">
    <td>A_TimeSinceThisHotkey</td>
    <td>从 A_ThisHotkey 按下后到现在经过的毫秒数. 如果 A_ThisHotkey 为空, 则此变量的值为空.</td>
  </tr>
  <tr id="TimeSincePriorHotkey">
    <td>A_TimeSincePriorHotkey</td>
    <td>从 A_PriorHotkey 按下后到现在经过的毫秒数. 如果 A_PriorHotkey 为空, 则此变量的值为 -1.</td>
  </tr>
  <tr id="EndChar">
    <td>A_EndChar</td>
    <td>用户最近按下的触发了<a href="Hotstrings.htm">非自动替换热字串</a>的<a href="Hotstrings.htm#EndChars">终止字符</a>. 如果不需要终止符(由于使用了 * 选项), 那么此变量将为空.</td>
  </tr>
  <tr id="MaxHotkeysPerInterval">
    <td>A_MaxHotkeysPerInterval</td>
    <td>可用于获取或设置在 A_HotkeyInterval 所定义的时间间隔内按下热键而不会触发警告对话框的最大数量. 有关详情, 请参阅 <a href="lib/A_MaxHotkeysPerInterval.htm">A_MaxHotkeysPerInterval</a>.</td>
  </tr>
  <tr id="HotkeyInterval">
    <td>A_HotkeyInterval</td>
    <td>可用于获取或设置 <a href="lib/A_MaxHotkeysPerInterval.htm">A_MaxHotkeysPerInterval</a> 使用的时间间隔长度, 以毫秒为单位.</td>
  </tr>
  <tr id="HotkeyModifierTimeout">
    <td>A_HotkeyModifierTimeout</td>
    <td>可用于获取或设置超时, 该超时影响带有以下<a href="Hotkeys.htm">热键</a>修饰符的 <a href="lib/Send.htm">Send</a> 的行为: <kbd>Ctrl</kbd>, <kbd>Alt</kbd>, <kbd>Win</kbd> 和 <kbd>Shift</kbd>. 有关详情, 请参阅 <a href="lib/A_HotkeyModifierTimeout.htm">A_HotkeyModifierTimeout</a>.</td>
  </tr>
</table>
<h3 id="os">操作系统和用户信息</h3>
<table class="info">
  <tr>
    <th abbr="Var">变量</th>
    <th abbr="Descr">描述</th>
  </tr>
  <tr id="ComSpec">
    <td>A_ComSpec</td>
    <td><p>包含与 ComSpec 环境变量相同的字符串, 通常是命令提示符可执行文件(cmd.exe) 的完整路径. 常与 <a href="lib/Run.htm">Run/RunWait</a> 一起使用. 例如:</p>
      <pre class="NoIndent no-highlight">C:\Windows\system32\cmd.exe</pre>
    </td>
  </tr>
  <tr id="Temp">
    <td>A_Temp</td>
    <td><p>存放临时文件的文件夹的完整路径和名称. 它的值从下列的其中一个位置检索(按顺序): 1) <a href="Concepts.htm#environment-variables">环境变量</a> TMP, TEMP 或 USERPROFILE; 2) Windows 目录. 例如:</p>
    <pre class="NoIndent no-highlight">C:\Users\&lt;UserName&gt;\AppData\Local\Temp</pre>
  </td>
  </tr>
  <tr id="OSVersion">
    <td>A_OSVersion</td>
    <td>
    <p>操作系统的版本号, 格式为 "<em>major</em>.<em>minor</em>.<em>build</em>". 例如, Windows 7 SP1 为 6.1.7601.</p>
    <p>在 AutoHotkey 可执行文件或已编译脚本的属性中应用兼容性设置会导致系统报告不同的版本号, 这将体现在 A_OSVersion 中.</p>
    </td>
  </tr>
  <tr id="Is64bitOS">
    <td>A_Is64bitOS</td>
    <td>当操作系统为 64 位则值为 1(true), 为 32 位则为 0(false).</td>
  </tr>
  <tr id="PtrSize">
    <td>A_PtrSize</td>
    <td>包含指针的大小值, 单位为字节. 值为 4(32 位) 或 8(64 位), 取决于运行当前脚本的执行程序的类型.</td>
  </tr>
  <tr id="Language">
    <td>A_Language</td>
    <td>当前系统的默认语言, 值为<a href="misc/Languages.htm">这些 4 位数字编码</a>的其中一个.</td>
  </tr>
  <tr id="ComputerName">
    <td>A_ComputerName</td>
    <td>在网络上看到的计算机名称.</td>
  </tr>
  <tr id="UserName">
    <td>A_UserName</td>
    <td>运行当前脚本的用户的登录名.</td>
  </tr>
  <tr id="WinDir">
    <td>A_WinDir</td>
    <td>Windows 目录. 例如: <code>C:\Windows</code></td>
  </tr>
  <tr id="ProgramFiles">
    <td>A_ProgramFiles</td>
    <td>
      <p>Program Files 目录(例如 <code>C:\Program Files</code> 或 <code>C:\Program Files (x86)</code>). 这通常与 <em>ProgramFiles</em> <a href="Concepts.htm#environment-variables">环境变量</a>相同.</p>
      <p>在 <a href="#Is64bitOS">64-位系统</a>(和非 32-位系统), 适用于下列内容:</p>
      <ul>
        <li>如果可执行文件(EXE) 以 32 位脚本运行的时候, A_ProgramFiles 返回路径为 "Program Files (x86)" 目录.</li>
        <li>对于 32 位的进程, <em>ProgramW6432</em> 环境变量指向 64 位 Program Files 目录的路径. 在 Windows 7 和更高版本上, 对于 64 位的进程也是这样设置的.</li>
        <li><em>ProgramFiles(x86)</em> 环境变量指向 32 位 Program Files 目录的路径.</li>
      </ul>
    </td>
  </tr>
  <tr id="AppData">
    <td>A_AppData</td>
    <td>
      <p>当前用户的应用程序数据文件夹的完整路径和名称. 例如:</p>
      <pre class="NoIndent no-highlight">C:\Users\&lt;UserName&gt;\AppData\Roaming</pre>
    </td>
  </tr>
  <tr id="AppDataCommon">
    <td>A_AppDataCommon</td>
    <td>
      <p>所有用户的应用程序数据文件夹的完整路径和名称. 例如:</p>
      <pre class="NoIndent no-highlight">C:\ProgramData</pre>
    </td>
  </tr>
  <tr id="Desktop">
    <td>A_Desktop</td>
    <td>
      <p>当前用户的桌面文件夹的完整路径和名称. 例如:</p>
      <pre class="NoIndent no-highlight">C:\Users\&lt;UserName&gt;\Desktop</pre>
    </td>
  </tr>
  <tr id="DesktopCommon">
    <td>A_DesktopCommon</td>
    <td>
      <p>所有用户的桌面文件夹的完整路径和名称. 例如:</p>
      <pre class="NoIndent no-highlight">C:\Users\Public\Desktop</pre>
    </td>
  </tr>
  <tr id="StartMenu">
    <td>A_StartMenu</td>
    <td>
      <p>当前用户的开始菜单文件夹的完整路径和名称. 例如:</p>
      <pre class="NoIndent no-highlight">C:\Users\&lt;UserName&gt;\AppData\Roaming\Microsoft\Windows\Start Menu</pre>
    </td>
  </tr>
  <tr id="StartMenuCommon">
    <td>A_StartMenuCommon</td>
    <td>
      <p>所有用户的开始菜单文件夹的完整路径和名称. 例如:</p>
      <pre class="NoIndent no-highlight">C:\ProgramData\Microsoft\Windows\Start Menu</pre>
    </td>
  </tr>
  <tr id="Programs">
    <td>A_Programs</td>
    <td>
      <p>当前用户的开始菜单中程序文件夹的完整路径和名称. 例如:</p>
      <pre class="NoIndent no-highlight">C:\Users\&lt;UserName&gt;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs</pre>
    </td>
  </tr>
  <tr id="ProgramsCommon">
    <td>A_ProgramsCommon</td>
    <td>
      <p>所有用户的开始菜单中程序文件夹的完整路径和名称. 例如:</p>
      <pre class="NoIndent no-highlight">C:\ProgramData\Microsoft\Windows\Start Menu\Programs</pre>
  </td>
  </tr>
  <tr id="Startup">
    <td>A_Startup</td>
    <td>
      <p>当前用户的开始菜单中启动文件夹的完整路径和名称. 例如:</p>
      <pre class="NoIndent no-highlight">C:\Users\&lt;UserName&gt;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</pre>
  </td>
  </tr>
  <tr id="StartupCommon">
    <td>A_StartupCommon</td>
    <td>
      <p>所有用户的开始菜单中启动文件夹的完整路径和名称. 例如:</p>
      <pre class="NoIndent no-highlight">C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup</pre>
  </td>
  </tr>
  <tr id="MyDocuments">
    <td>A_MyDocuments</td>
    <td>
      <p>当前用户 "我的文档" 文件夹的完整路径和名称. 与大多数类似变量不同, 当此文件夹为驱动器的根目录时, 此变量的值不包含最后的反斜杠(例如, 它的值是 <code>M:</code> 而不是 <code>M:\</code>). 例如:</p>
      <pre class="NoIndent no-highlight">C:\Users\&lt;UserName&gt;\Documents</pre>
  </td>
  </tr>
  <tr id="IsAdmin">
    <td>A_IsAdmin</td>
    <td><p>如果当前用户有管理员权限, 则值为 1, 否则为 0.</p>
    <p id="RequireAdmin">要使脚本以管理员权限重新启动(或显示提示向用户请求管理员权限), 请使用 <a href="lib/Run.htm#RunAs">Run *RunAs</a>. 但是请注意, 以管理员权限运行脚本会导致脚本启动的所有程序也以管理员权限运行. 对于可能的替代方案, 请参阅<a href="FAQ.htm#uac">常见问题(FAQ)</a>.</p>
    </td>
  </tr>
  <tr id="Screen">
    <td><p>A_ScreenWidth<br>
    A_ScreenHeight</p></td>
    <td><p>主监视器的宽度和高度, 单位为像素(例如 1024 和 768).</p>
      <p>要获取多显示器系统中其他显示器的尺寸, 请使用 <a href="lib/SysGet.htm">SysGet</a>.</p>
      <p>要获取整个桌面(即使它横跨多个显示器) 的宽度和高度, 请使用下面的例子:</p>
<pre>
VirtualWidth := <a href="lib/SysGet.htm">SysGet</a>(78)
VirtualHeight := <a href="lib/SysGet.htm">SysGet</a>(79)
</pre>
    <p>此外, 使用 <a href="lib/SysGet.htm">SysGet</a> 可以获取显示器的工作区域, 它比显示器的整个区域小, 因为它不包括任务栏和其他注册的桌面工具栏.</p></td>
  </tr>
  <tr id="ScreenDPI">
    <td>A_ScreenDPI</td>
    <td>沿屏幕宽度每逻辑英寸的像素数. 在具有多个显示监视器的系统中, 此值对于所有监视器都是相同的. 在大多数系统中该值为 96; 它取决于系统文本大小(DPI) 设置. 另请参阅 GUI 的 <a href="lib/Gui.htm#DPIScale">-DPIScale</a> 选项.</td>
  </tr>
</table>
<h3 id="misc">杂项</h3>
<table class="info">
  <tr>
    <th abbr="Var">变量</th>
    <th abbr="Descr">描述</th>
  </tr>
  <tr id="Clipboard">
    <td>A_Clipboard</td>
    <td>可用于获取或设置系统剪贴板的内容. 有关详情, 请参阅 <a href="lib/A_Clipboard.htm">A_Clipboard</a>.</td>
  </tr>
  <tr id="Cursor">
    <td>A_Cursor</td>
    <td><p>当前显示的鼠标光标类型. 其值为下列单词的其中一个: AppStarting(程序启动, 后台运行--箭头+等待), Arrow(箭头, 正常选择--标准光标), Cross(十字, 精确选择), Help(帮助, 帮助选择--箭头+问号), IBeam(工字光标, 文本选择--输入), Icon, No(No, 不可用--圆圈加反斜杠), Size, SizeAll(所有尺寸, 移动--四向箭头), SizeNESW(东南和西北尺寸, 沿对角线调整 2--双箭头指向东南和西北), SizeNS(南北尺寸, 垂直调整--双箭头指向南北), SizeNWSE(西北和东南尺寸, 沿对角线调整 1--双箭头指向西北和东南), SizeWE(东西尺寸, 水平调整--双箭头指向东西), UpArrow(向上箭头, 候选--指向上的箭头), Wait(等待, 忙--沙漏或圆圈), Unknown(未知). 与 size-类型光标一起使用的缩略词是罗盘方向, 例如 NESW = NorthEast(东北)+SouthWest(西南). 手型指针(点击和抓取) 属于 Unknown 类别.</p></td>
  </tr>
  <tr id="EventInfo">
    <td>A_EventInfo</td>
    <td><p>包含下列事件的额外信息:</p>
      <ul>
        <li><a href="Hotkeys.htm#Wheel">鼠标滚轮热键</a>(WheelDown/Up/Left/Right)</li>
        <li><a href="lib/OnMessage.htm">OnMessage</a></li>
        <li><a href="misc/RegExCallout.htm">Regular Expression Callouts</a></li>
      </ul>
      <p>注意: 与类似 A_ThisHotkey 这样的变量不同, 每个<a href="misc/Threads.htm">线程</a>保留自身的 A_EventInfo 值. 因此, 如果一个线程被另一个中断, 在这个线程恢复时它仍将看到这些变量的原来/正确的值.</p>
      <p>脚本也可以设置 A_EventInfo, 但只能在指针可用的范围内接受无符号整数(32-bit 或 64-bit 取决于 AutoHotkey 的版本).</p></td>
  </tr>
  <tr id="LastError">
    <td>A_LastError</td>
    <td><p>这通常是脚本调用某些函数后, 包括 <a href="lib/DllCall.htm">DllCall</a>, <a href="lib/Run.htm">Run/RunWait</a>, File/Ini/Reg 函数(在文档中) 和可能的其他函数, 系统 GetLastError() 函数的结果. A_LastError 是一个介于 0 和 4294967295 之间的数字(通常格式化为十进制, 而不是十六进制). 零(0) 表示成功, 但是任何其他数字都表示调用失败. 每个数字对应一个特定的错误条件. 要了解如何获得本地化的错误描述文本, 请参阅 <a href="lib/Error.htm#OSError">OSError</a>, 或在 <a href="http://www.microsoft.com">www.microsoft.com</a> 搜索 "系统错误代码", 以获得列表. A_LastError 是每个线程的设置; 也就是说, 被其他<a href="misc/Threads.htm">线程</a>中断不能改变它.</p>
    <p>给 A_LastError 赋值, 也会调用系统的 SetLastError() 函数.</p></td>
  </tr>
  <tr id="TrueFalse">
    <td>True<br />False</td>
    <td><p>包含 1 和 0. 它们可以用来使脚本更具可读性. 有关详情, 请参阅<a href="Concepts.htm#boolean">布尔值</a>.</p>
      <p>这些实际上是<a href="Language.htm#constants">关键字</a>, 而不是变量.</p>
    </td>
  </tr>
</table>
<h3 id="loop">Loop</h3>
<table class="info">
  <tr>
    <th abbr="Var">变量</th>
    <th abbr="Descr">描述</th>
  </tr>
  <tr id="Index">
    <td>A_Index</td>
    <td>可用于获取或设置当前循环迭代的次数(64 位整数). 第一次循环体执行时, 它为 1. 第二次, 它的值为 2; 依次类推. 如果一个内循环被外循环包围, 那么内循环优先. A_Index 在<a href="Language.htm#loop-statement">所有类型的循环</a>中都起作用, 但在循环语句外值为 0. 对于像 <a href="lib/Loop.htm">Loop</a> 这样的计数循环, 更改 A_Index 会影响将要执行的迭代次数.</td>
  </tr>
  <tr>
    <td>A_LoopFileName, 等</td>
    <td>此变量和其他相关变量仅在<a href="lib/LoopFiles.htm">文件循环</a>中有效.</td>
  </tr>
  <tr>
    <td>A_LoopRegName, 等</td>
    <td>此变量和其他相关变量仅在<a href="lib/LoopReg.htm">注册表循环</a>中有效.</td>
  </tr>
  <tr>
    <td>A_LoopReadLine</td>
    <td>请参阅<a href="lib/LoopRead.htm">文件读取循环</a>.</td>
  </tr>
  <tr>
    <td>A_LoopField</td>
    <td>请参阅<a href="lib/LoopParse.htm">解析循环</a>.</td>
  </tr>
</table>

<h2 id="cap">变量的容量和占用内存</h2>
<ul>
  <li>当赋值给变量比当前更长的内容时, 会自动分配额外的系统内存给这个变量.</li>
  <li>通过赋值为空, 可以释放大变量占用的内存, 例如 <code>var := ""</code>.</li>
  <li>脚本可以创建的变量数量没有限制. 程序设计用来支持至少几百万的变量而不会出现明显的性能下降.</li>
  <li>接受数字输入的函数和表达式通常支持 15 位的浮点数精度. 对于整数, 可以支持 64 位有符号整数, 其范围从 -9223372036854775808(-0x8000000000000000) 到 9223372036854775807(0x7FFFFFFFFFFFFFFF). 任何超出此范围的整数常量都将回绕. 同样的, 整数的算数运算结果超出此范围时会溢出回绕(例如 0x7FFFFFFFFFFFFFFF + 1 = -0x8000000000000000).</li>
</ul>
</body>
</html>