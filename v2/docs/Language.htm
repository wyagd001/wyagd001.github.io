<!DOCTYPE HTML>
<html lang="zh">
<head>
<title>脚本语言 | AutoHotkey v2</title>
<meta name="description" content="Learn details about the language such as comments, expressions, control flow statements, structure of a script, etc." />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
</head>
<body>
<h1>脚本语言</h1>
<p>一个 AutoHotkey 脚本从根本上说是使用 AutoHotkey 独有的自定义语言编写的程序要遵循的指令集合. 这种语言与其他几种脚本语言有一些相似之处, 但也有其独特的优势和缺陷. 本文档描述了该语言, 并试图指出常见的缺陷.</p>
<p class="note">有关 AutoHotkey 所使用的各种概念的更一般的解释, 请参阅<a href="Concepts.htm">概念和约定</a>.</p>

<h2>目录</h2>
<ul>
  <li><a href="#general-conventions">常规约定</a></li>
  <li><a href="#comments">注释</a></li>
  <li><a href="#expressions">表达式</a>
  <ul>
    <li><a href="#strings">字符串 / 文本</a></li>
    <li><a href="#variables">变量</a></li>
    <li><a href="#operators">运算符</a></li>
    <li><a href="#function-calls">函数调用</a>
    <ul>
      <li><a href="#function-call-statements">函数调用语句</a></li>
      <li><a href="#optional-parameters">可选参数</a></li>
    </ul></li>
    <li><a href="#operators-for-objects">对象的运算符</a></li>
    <li><a href="#expression-statements">表达式语句</a></li>
  </ul></li>
  <li><a href="#control-flow">控制流语句</a>
  <ul>
    <li><a href="#control-flow-vs">控制流 vs. 其他语句</a></li>
    <li><a href="#loop-statement">Loop 语句</a></li>
    <li><a href="#not-control-flow">非控制流</a></li>
  </ul></li>
  <li><a href="#structure-of-a-script">脚本的结构</a>
  <ul>
    <li><a href="#auto-execute-section">自动执行段</a></li>
    <li><a href="#subroutines">子程序</a></li>
    <li><a href="#user-defined-functions">用户定义的函数</a></li>
    <li><a href="#-include">#Include</a></li>
  </ul></li>
  <li><a href="#misc">杂项</a>
  <ul>
    <li><a href="#dynamic-variables">动态变量</a>
    <ul>
      <li><a href="#pseudo-arrays">伪数组</a></li>
      <li><a href="#associative-pseudo-arrays">关联伪数组</a></li>
    </ul></li>
    <li><a href="#labels">标签</a></li>
  </ul></li>
</ul>
<!-- TODO:
Directives
Declarations
Class definitions
Methods?
-->

<h2 id="general-conventions">常规约定</h2>
<p><strong>名称:</strong> 变量和函数名称不区分大小写(例如, <code>CurrentDate</code> 等同于 <code>currentdate</code>). 有关详细信息(如最大长度和可用字符), 请参阅<a href="Concepts.htm#names">名称</a>.</p>
<p><strong>无类型变量:</strong> 变量没有明确定义的类型; 相反, 任何类型的值都可以存储在任何变量中(不包括内置变量). 数字可能会自动转换为字符串(文本), 反之亦然, 这取决于实际情况.</p>
<p><strong>声明是可选的:</strong> 除了在<a href="Functions.htm">函数页面</a>上注明的地方外, 变量不需要声明; 它们的存在仅仅是通过使用它们(每个变量都是从空/空白开始的).</p>
<p><strong>空格通常被忽略:</strong> 缩进(前导空格) 对于编写可读代码非常重要, 但是程序不需要, 通常会被忽略. <em>通常</em> 在行尾的, 表达式内的(引号之间的除外), 以及命令参数之前和之后的空格和制表符会被忽略. 然而, 在一些情况下, 空格是重要的, 包括:</p>
<ul>
  <li><a href="#function-calls">函数</a>和方法调用要求在函数/方法名称和 <code>(</code> 之间没有空格.</li>
  <li>执行连接时需要空格.</li>
  <li>两个运算符之间可能需要空格, 以消除歧义.</li>
  <li>单行<a href="#comments">注释</a>如果不在行首, 则需要前导空格.</li>
</ul>
<p><strong>换行符是有意义的:</strong> 换行符通常作为语句分隔符, 终止前一个函数或其他语句. (<em>语句</em> 只是语言中表示要执行某些操作的最小的独立元素.) 这个例外是行延续(请参见下文).</p>
<p><strong>行延续:</strong> 长行可以分成一些小行, 以提高可读性和可维护性. 这是通过预处理实现的, 所以不属于这种语言的一部分. 有三种方法:</p>
<ul>
  <li><a href="Scripts.htm#continuation-line">延续前缀</a>: 以<a href="Variables.htm#operators">表达式运算符</a>(++ 和 -- 除外) 开头的行与前一行合并. 无论该行是否实际包含表达式, 都会合并行.</li>
  <li><a href="Scripts.htm#continuation-expr">延续闭环</a>: 在大多数情况下, 括在 (), [] 或 {} 中的子表达式可以自动跨越多行.</li>
  <li><a href="Scripts.htm#continuation-section">延续片段</a>: 片段中的多行与片段上面那一行合并, 延续片段以 <code>(</code> 开始, 以 <code>)</code> 结束(两个符号必须出现在行的开头, 不计空格).</li>
</ul>

<h2 id="comments">注释</h2>
<p><em>注释</em> 是脚本中被程序忽略的那部分文本. 它们通常用于添加解释或禁用部分代码.</p>
<p>可以通过在行的开头使用分号来注释脚本. 例如:</p>
<pre><em>; 这一整行都是注释.</em></pre>
<p>也可以在行的末尾添加注释, 此时分号左侧必须至少有一个空格或 tab. 例如:</p>
<pre>Run "Notepad"  <em>; 这是与函数调用在同一行上的注释.</em></pre>
<p>此外, 可以使用 <code><em>/*</em></code> 和 <code><em>*/</em></code> 符号注释掉整块代码, <em>但仅当它们出现在行首时才有效</em>(对于 <code><em>*/</em></code>, 可以在行的开头或结尾处), 如下例所示:</p>
<pre><em>/*
MsgBox "这行被注释(禁用) 掉了."
MsgBox "常见的错误:" */ " 这不会结束注释."
MsgBox "这行被注释掉了."
*/</em>
MsgBox "这行没有被注释."
<em>/* 这也是有效注释, 但是这一行不能有其他代码. */</em>
</pre>
<p>由于脚本运行时会忽略注释, 所以它们不会影响脚本性能或占用内存.</p>

<h2 id="expressions">表达式</h2>
<p><strong><em>表达式</em></strong> 是一个或多个<a href="Concepts.htm#values">值</a>, <a href="Concepts.htm#variables">变量</a>, <a href="#operators">运算符</a>和<a href="#function-calls">函数调用</a>的组合. 例如, <code>10</code>, <code>1+1</code> 和 <code>MyVar</code> 都是有效的表达式. 通常, 表达式将一个或多个值作为输入, 执行一个或多个操作, 并生成一个值作为结果. 找出表达式值的过程被称为 <em>计算</em>. 例如, 表达式 <code>1+1</code> <em>计算</em> 出数字 2.</p>
<p>简单的表达式可以拼凑在一起形成更复杂的表达式. 例如, 如果 <code>Discount/100</code> 将折扣百分比转换为分数, <code>1 - Discount/100</code> 计算剩余金额的分数, 而 <code>Price * (1 - Discount/100)</code> 应用它来产生净价格.</p>
<p><em>值</em> 是<a href="Concepts.htm#numbers">数字</a>, <a href="Concepts.htm#objects">对象</a>或<a href="Concepts.htm#strings">字符串</a>. <em>原义</em> 值是在脚本中实际写入的值; 当您在查看代码时可以看到该值(文字).</p>

<h3 id="strings">字符串 / 文本</h3>
<p class="note">有关字符串的更一般的解释, 请参阅<a href="Concepts.htm#strings">字符串</a>.</p>
<p><em>字符串</em> 或 <em>字符组成的串</em>, 只是一个文本值. 在表达式中, 原义的文本必须用引号引起来, 以区分变量名称或其他表达式. 这通常被称为 <em>加引号的原义字符串</em>, 或者为 <em>加引号的字符串</em>. 例如, <code>"this is a quoted string"</code> 和 <code>'so is this'</code>.</p>
<p>要在原义字符串中包含 <em>真实的</em> 引号字符, 请使用<a href="misc/EscapeChar.htm#quote">转义序列</a> <code>`"</code> 或 <code>`'</code>, 或将字符括在相反类型的引号中. 例如: <code>'She said, "An apple a day."'</code>.</p>
<p>加引号的字符串能包含其他的<a href="misc/EscapeChar.htm">转义序列</a>, 如 <code>`t</code>(制表符), <code>`n</code>(换行) 和 <code>`r</code>(回车).</p>

<h3 id="variables">变量</h3>
<p class="note">有关变量的基本解释和常规细节, 请参阅<a href="Concepts.htm#variables">变量</a>.</p>
<p><em>变量</em> 可以简单地通过写变量的名称来用于表达式. 例如, <code>A_ScreenWidth/2</code>. 但是, 变量不能在加引号的字符串中使用. 作为替代, 变量和其他值可以通过名为 <a href="Variables.htm#concat"><em>连接</em></a> 的过程与文本组合起来. 有两种方法能用于 <em>连接</em> 表达式中的值:</p>
<ul>
  <li>隐式连接: <code>&quot;The value is &quot; MyVar</code></li>
  <li>显式连接: <code>&quot;The value is &quot; . MyVar</code></li>
</ul>
<p>隐式连接也被称为 <em>自动连接</em>. 在这两种情况下, 变量和点之前的空格都是必需的.</p>
<p><a href="commands/Format.htm">Format</a> 函数也可以用于此目的. 例如:</p>
<pre>MsgBox Format("You are using AutoHotkey v{1} {2}-bit.", A_AhkVersion, A_PtrSize*8)
</pre>
<p>要为变量赋值, 请使用 <code>:=</code> <a href="Variables.htm#AssignOp">赋值运算符</a>, 如 <code>MyVar := &quot;Some text&quot;</code>.</p>
<p>表达式中的 <em>百分号</em> 用于创建<a href="#dynamic-variables">动态变量引用</a>和<a href="Functions.htm#DynCall">动态函数调用</a>, 但这些很不常见.</p>

<h3 id="operators">运算符</h3>
<p><em>运算符</em> 采用符号或符号组的形式(如 <code>+</code> 或 <code>:=</code>), 或者下列其中一个单词 <code>and</code>, <code>or</code>, <code>not</code>, <code>new</code>, <code>is</code>, <code>in</code> 或 <code>contains</code>. 它们将一个, t两个或三个值作为输入, 并返回一个值作为结果. 用作运算输入的值或子表达式称为 <em>运算元</em>.</p>
<ul>
  <li><em>一元</em> 运算符可以写在单个运算元的前面或后面, 这取决于运算符. 例如, <code>-x</code> 或 <code>not keyIsDown</code>.</li>
  <li><em>二元</em> 运算符写在两个运算元之间. 例如, <code>1+1</code> 或 <code>2 * 5</code>.</li>
  <li>AutoHotkey 只有一个 <em>三元</em> 运算符, 它采用如下的形式 <a href="Variables.htm#ternary"><code>condition ? valueIfTrue : valueIfFalse</code></a>.</li>
</ul>
<p>一些一元和二元运算符共享相同的符号, 在这种情况下, 运算符的含义取决于它是写在两个值之前, 之后还是之间. 例如, <code>x-y</code> 执行减法, 而 <code>-x</code> 反转 <code>x</code> 的符号(从负值产生正值, 反之亦然).</p>
<p>除非在<a href="Variables.htm#operators">运算符表</a>中另有规定, 否则优先级相等的运算符(如 乘号(<code>*</code>) 和除号(<code>/</code>)) 按从左到右的顺序计算. 相反, 诸如加(<code>+</code>) 之类的优先级较低的运算符在诸如乘(<code>*</code>) 之类的优先级较高运算符之后被计算. 例如, <code>3 + 2 * 2</code> 作为 <code>3 + (2 * 2)</code> 计算. 括号可以用来覆盖优先级, 如以下示例所示: <code>(3 + 2) * 2</code></p>

<h3 id="function-calls">函数调用</h3>
<p class="note">有关函数和相关术语的一般解释, 请参阅<a href="Concepts.htm#functions">函数</a>.</p>
<p><em>函数</em> 接受可变数量的输入, 去执行一些动作或计算, 然后 <a href="Concepts.htm#return-a-value"><em>return</em>(返回)</a> 一个结果. 函数的输入被称为<a href="Concepts.htm#parameters">参数</a>(<em>parameters</em> 或 <em>arguments</em>). 一个函数被简单地通过写它的名字, 后跟着用括号括起来的参数来 <a href="Concepts.htm#call"><em>called</em>(调用)</a>. 例如, 如果 <kbd>Shift</kbd> 键被按下, 则 <code>GetKeyState(&quot;Shift&quot;)</code> 返回(计算为) 1, 否则返回 0.</p>
<p class="warning"><strong>注意:</strong> 函数名和左括号之间不能有任何空格.
</p>
<p>对于刚接触编程的人来说, 括号的要求起初可能看起来很神秘或冗长, 但它们允许将函数调用与其他操作结合起来. 例如, 只有当两个键被物理按下时, 表达式 <code>GetKeyState(&quot;Shift&quot;, &quot;P&quot;) and GetKeyState(&quot;Ctrl&quot;, &quot;P&quot;)</code> 才会返回 1.</p>
<p>函数名与变量名是分开的. 例如, <code>Round</code> 可以同时是变量名和函数名, 而 <code>Round := 1</code> 不会以任何方式影响 <code>Round(n)</code>.</p>
<p>与普通<a href="Functions.htm#Global">全局变量</a>不同, 默认情况下函数可以在其他函数的内部调用. 但是, <a href="Functions.htm#nested">套嵌函数</a>(即, 在另一个函数中 <em>定义的</em> 任何函数) 只能在包含它们的函数内通过名称来访问.</p>

<h4 id="function-call-statements">函数调用语句</h4>
<p>如果不需要函数的返回值, 并且函数名写在行首(或者在其他允许<a href="Concepts.htm#statement">语句</a>的上下文中, 如下面的 <code>else</code> 或 <a href="Hotkeys.htm">hotkey 标签</a>), 则可以省略括号. 在这种情况下, 行的其余部分作为函数的参数列表. 例如:</p>
<pre>result := MsgBox("This one requires parentheses.",, "OKCancel")
MsgBox "This one doesn't. The result was " result "."</pre>
<p>已知限制:</p>
<ul>
  <li>如果脚本通过定义具有相同名称的函数来覆盖内置函数,如果省略括号, 根据函数的不同, 内置函数可能(或不能) 仍然被调用.</li>
  <li>当圆括号被省略时, 内置函数的 Output 变量目前不允许为表达式. 例如, <code>MouseGetPos whichvar ? x1 : x2</code> 是无效, 但 <code>MouseGetPos(whichvar ? x1 : x2)</code> 是有效的.</li>
</ul>

<h4 id="optional-parameters">可选参数</h4>
<p>可选参数可以简单地留空, 但是分隔逗号仍然是必需的, 除非所有后续参数也被省略. 例如, <a href="commands/Run.htm">Run</a> 函数可接受一至四个参数. 下列各项均有效:</p>
<pre>
Run "notepad.exe", "C:\"
Run "notepad.exe",, "Min"
Run("notepad.exe", , , notepadPID)
</pre>

<h3 id="operators-for-objects">对象的运算符</h3>
<p>这里表达式中使用的其他符号不完全符合上面定义的任何类别, 或影响表达式其他部分的含义, 如下所述. 这些都以某种方式与 <em>对象</em> 有关. 对于每个构造所做的事情提供一个完整的解释, 需要引入更多的概念, 而这不属于本节的范围.</p>
<p><code>Alpha.Beta</code> 通常称为 <em>成员访问</em>. <em>Alpha</em> 是一个普通变量, 可以用函数调用或其他一些返回对象的子表达式替换. 当计算时, 对象发送一个请求 &quot;给我属性 <em>Beta</em> 的值&quot;, &quot;在属性 <em>Beta</em> 中存储这个值&quot; 或 &quot;调用名为 <em>Beta</em> 的方法&quot;. 换句话说, <em>Beta</em> 是一个对对象有意义的名字; 它不是一个局部或全局变量.</p>
<p><code>Alpha.Beta()</code> 是一个 <em>方法调用</em>, 如上所述.</p>
<p><code>Alpha.Beta[Param]</code> 是成员访问的一种特殊形式, 其中包括了请求中的附加参数. <em>Beta</em> 只是一个简单的名称, <em>Param</em> 是一个普通的变量或子表达式, 或者是由逗号分隔的子表达式列表(与函数的参数列表中相同). <a href="Functions.htm#VariadicCall">Variadic calls</a> are permitted.</p>
<p><code>Alpha[Index]</code> accesses the <em>default property</em> of <code>Alpha</code>, giving <code>Index</code> as a parameter. Both <em>Alpha</em> and <em>Index</em> are variables in this case, and could be replaced with virtually any sub-expression. 此语法通常用于检索<a href="Objects.htm#Usage_Simple_Arrays">数组</a>或<a href="Objects.htm#Usage_Associative_Arrays">关联数组</a>中的元素.</p>
<p class="warning"><strong>Note:</strong> Currently properties and methods are defined as associative array elements, and as such, the syntax can usually be used interchangebly. However, this will be changed in a future alpha release. It is important to use the syntax appropriate to the situation.</p>
<p><code>new ClassName()</code> 用于实例化一个类, 或者创建一个从另一个对象派生的对象. 虽然这看起来像一个函数调用, 但 <em>ClassName</em> 实际上是一个普通的变量. 同样, <code>new Alpha.Beta()</code> 将创建一个由 <code>Alpha.Beta</code> 返回的对象派生的对象; <em>Beta</em> 既不是函数也不是方法. 如果可选的括号存在, 则可能包含对象的 <a href="Objects.htm#Custom_NewDelete">__New</a> 方法的参数.</p>
<p id="array-literal"><code>[A, B, C]</code> 创建一个初始内容为 A, B 和 C(本例中的所有变量) 的<a href="Objects.htm#Usage_Simple_Arrays">数组</a>, 其中 A 是元素 1.</p>
<p id="object-literal"><code>{Key1: Value1, Key2: Value2}</code> 由键值对列表创建<a href="Objects.htm#Usage_Associative_Arrays">关联数组</a>. 一个值以后可以通过它关联的键来检索. 在 <code>:</code> 的左侧写入一个简单的单词(由字母数字字符, 下划线和非 ASCII 字符组成) 等同于将该单词括在引号中. 例如, <code>{A: B}</code> 等同于 <code>{&quot;A&quot;: B}</code>. 但是, <code>{(A): B}</code> 使用变量 <code>A</code> 的内容作为键.</p>
<p><code>MyFunc(Params*)</code> 是一个<a href="Functions.htm#VariadicCall">可变函数调用</a>. 星号必须紧接在函数参数列表末尾的右括号之前. <em>Params</em> 必须是返回数组对象的变量或子表达式.  虽然在任何地方使用 <code>Params*</code> 都是无效的, 但它可以用在数组标识符 (<code>[A, B, C, ArrayToAppend*]</code>) 或索引器 (<code>Alpha[Params*]</code>) 中.</p>

<h3 id="expression-statements">表达式语句</h3>
<p>并不是所有的表达式都可以单独在一行上使用. 例如, 只包含 <code>21*2</code> 或 <code>&quot;Some text&quot;</code> 的行就没有任何意义. 表达式 <em>语句</em> 是一个单独使用的表达式, 通常利用它的附加作用. 大多数带有附加作用的表达式都可以这样使用, 所以一般不需要记住本节的细节.</p>
<p>以下类型的表达式可以用作语句:</p>
<p>赋值(如 <code>x := y</code>), 复合赋值(如 <code>x += y</code>) 和增量/减量运算符(如 <code>++x</code> 和 <code>x--</code>).</p>
<p class="warning"><strong>已知限制:</strong> 对于 <code>x++</code> 和 <code>x--</code>, 目前变量名和运算符之间不能有空格.</p>
<p>函数调用(如 <code>MyFunc(Params)</code>). 但是, 一个独立的函数调用不能跟随一个左大括号 <code>{</code>(在行尾或下一行), 因为它会与函数声明混淆.</p>
<p>方法调用(如 <code>MyObj.MyMethod()</code>).</p>
<p>使用方括号的成员访问(如 <code>MyObj[Index]</code>), 它可能有类似于函数调用的附加作用.</p>
<p>以 <code>new</code> 运算符开始的表达式(如 <code>new ClassName</code>), 因为有时一个类可以被实例化, 只是为了它的附加作用.</p>
<p>三元表达式(如 <code>x? CallIfTrue() : CallIfFalse()</code>).</p>
<p class="warning"><strong>已知限制:</strong>  由于<a href="#function-call-statements">函数调用语句</a>的模糊性, 以变量名和空格开头的条件(还包含其他操作符) 应该用圆括号括起来. 例如, <code>(x + 1) ? y : z</code> 和 <code>x+1 ? y : z </code> 是表达式语句, 但是 <code>x + 1 ? y : z</code> 是函数调用语句.</p>
<p>以 <code>(</code> 开始的表达式. 但是, 通常必须在同一行有一个匹配的 <code>)</code>, 否则该行将被解释为<a href="Scripts.htm#continuation">延续片段</a>的开始.</p>
<p>以双百分号开始的表达式(如 <code>%varname% := 1</code>). 这主要是由于实现的复杂性.</p>
<p>为简单起见, 也允许以上面描述的任一表达式(但不包括下面描述的) 开始的表达式. 例如, <code>MyFunc()+1</code> 目前是允许的, 尽管 <code>+1</code> 没有效果, 其结果会被丢弃. 由于错误检查的增强, 这些表达式在将来可能会失效.</p>
<p>缺少圆括号的方法调用将行其余部分作为参数列表. 例如, <code>ExcelApp.Quit</code> 或 <code>x.y.z "my parameter"</code>. 这不是一个表达式, 而是一个方法调用语句.</p>

<h2 id="control-flow">控制流语句</h2>
<p class="note">有关控制流的一般说明, 请参阅<a href="Concepts.htm#control-flow">控制流</a>.</p>
<p><a href="Concepts.htm#statement">语句</a> 通过将他们括在大括号(<code>{}</code>) 中(如 C, JavaScript 和类似语言) 组合成 <a href="commands/Block.htm"><em>块</em></a>, 但通常大括号必须出现在行的开头. 控制流语句可以应用于整个块或者只是单一语句.</p>
<p>控制流程语句的<a href="Concepts.htm#cf-body">主体</a>总是 <em>一组</em> 语句. 块被视为一组语句, 就像控制流语句及其主体一样. 以下相关语句与其主体一起彼此分组: <code>If</code> 和 <code>Else</code>; <code>Loop</code>/<code>For</code> 和 <code>Until</code>; <code>Try</code> 和 <code>Catch</code> 和/或 <code>Finally</code>. 换句话说, 当这些语句组作为一个整体使用时, 并不总是需要用大括号括起来(但是, 为了清楚起见, 一些编码样式总是包含大括号).</p>
<p>控制流语句, 它具有一个主体, 因此必须总是跟着一个相关的语句或一组语句: <code>If</code>, <code>Else</code>, <code>Loop</code>, <code>While</code>, <code>For</code>, <code>Try</code>, <code>Catch</code> 和 <code>Finally</code>.</p>
<p id="control-flow-list">下面的控制流语句如下::</p>
<ul>
  <li>一个<a href="commands/Block.htm">块</a>(用一对大括号表示) 将零个或多个语句组合为一个语句.</li>
  <li><a href="commands/IfExpression.htm">If 语句</a>导致其主体被执行或不依赖条件. 其后可以跟一个 <a href="commands/Else.htm">Else</a> 语句, 只有当条件不满足时才执行.</li>
  <li><a href="commands/Goto.htm">Goto</a> 跳转到指定的标签并继续执行.</li>
  <li><a href="commands/Gosub.htm">Gosub</a> 调用一个<a href="#subroutines">子程序</a>.</li>
 <li><a href="commands/Return.htm">Return</a> 从一个<a href="#subroutines">子程序</a>或函数返回.</li>
  <li>一个 <a href="#loop-statement">Loop(循环) 语句</a> (<a href="commands/Loop.htm">Loop</a>, <a href="commands/While.htm">While</a> 或 <a href="commands/For.htm">For</a>) 重复执行其主体.
  <ul>
    <li><a href="commands/Break.htm">Break</a> 退出(终止) 一个循环.</li>
    <li><a href="commands/Continue.htm">Continue</a> 跳过当前循环迭代的其余部分, 并开始一个新的循环.</li>
    <li><a href="commands/Until.htm">Until</a> 直到表达式计算结果为 true 时, 循环终止. 表达式在每次迭代之后被计算.</li>
  </ul></li>
  <li>异常处理:
  <ul>
    <li><a href="commands/Try.htm">Try</a> 保护它的主体不受运行错误和 throw 语句抛出的异常的影响.</li>
    <li><a href="commands/Catch.htm">Catch</a> 在 try 语句中抛出异常后执行它的主体(仅当在抛出异常的情况下).</li>
    <li><a href="commands/Finally.htm">Finally</a> 在当控制权从 try 或 catch 语句的主体转出时, 执行其主体.</li>
    <li><a href="commands/Throw.htm">Throw</a> 抛出一个异常, 通过 try/catch 或显示错误对话框来处理.</li>
  </ul></li>
</ul>

<h3 id="control-flow-vs">控制流与其他语句</h3>
<p>控制流语句与<a href="#function-call-statements">函数调用语句</a>在以下几个方面不同:</p>
<ul>
  <li><a href="commands/Block.htm">块</a>的左大括号可以写在 <a href="commands/IfExpression.htm">If</a>, <a href="commands/Else.htm">Else</a>, <a href="#loop-statement">Loop</a>, <a href="commands/While.htm">While</a>, <a href="commands/For.htm">For</a>, <a href="commands/Try.htm">Try</a>, <a href="commands/Catch.htm">Catch</a> 或 <a href="commands/Finally.htm">Finally</a> 语句(基本上是任何具有<a href="Concepts.htm#cf-body">主体</a>的控制流语句) 同一行的末尾. 这被称为 One True Brace(OTB) 样式.</li>
  <li><a href="commands/Else.htm">Else</a>, <a href="commands/Try.htm">Try</a> 和 <a href="commands/Finally.htm">Finally</a> 允许任何有效的语句在其右侧, 因为它们需要一个<a href="Concepts.htm#cf-body">主体</a>但没有参数.</li>
  <li><a href="commands/IfExpression.htm">If</a>, <a href="commands/While.htm">While</a>, <a href="commands/Return.htm">Return</a>, <a href="commands/Until.htm">Until</a>, <a href="commands/Loop.htm">Loop <em>Count</em></a>, <a href="commands/Goto.htm">Goto</a> 和 <a href="commands/Gosub.htm">Gosub</a> 允许在名称后立即使用左括号, 将整个参数列表括起来. 虽然这些看起来像函数调用, 但它们不是, 也不能在表达式中间使用. 例如, <code>if(expression)</code>.</li>
  <li>不能通过定义具有相同名称的函数来覆盖控制流语句.</li>
</ul>

<h3 id="loop-statement">Loop 语句</h3>
<p>有几种类型的 loop 语句:</p>
<ul>
  <li><a href="commands/Loop.htm">Loop <em>Count</em></a> 重复执行一个语句: 可以指定表示重复次数的数字(Count) 或直到遇到 <a href="Break.htm">break</a>.</li>
  <li><a href="commands/LoopReg.htm">Loop Reg</a> 获取指定的注册表子键的内容,每次一个项目.</li>
  <li><a href="commands/LoopFiles.htm">Loop Files</a> 获取指定的文件或文件夹, 每次一个.</li>
  <li><a href="commands/LoopParse.htm">Loop Parse</a> 从一个字符串中获取子字符串(片段), 每次一个.</li>
  <li><a href="commands/LoopRead.htm">Loop Read</a> 获取文本文件中的行, 每次一行.</li>
  <li><a href="commands/While.htm">While</a> 重复执行一个语句, 一直到指定的<a href="../Variables.htm#Expressions">表达式</a>计算结果为假. 每次迭代(重复) 前计算表达式的结果.</li>
  <li><a href="commands/For.htm">For</a> 对每一个值或枚举器返回的每对键值对执行一个语句, 如对象中的每对键值对.</li>
</ul>
<p><a href="commands/Break.htm">Break</a> 退出(终止) 一个循环, 有效地跳到循环主体后面的下一行.</p>
<p><a href="commands/Continue.htm">Continue</a> 跳过当前循环迭代的其余部分, 并开始一个新的循环.</p>
<p><a href="commands/Until.htm">Until</a> 表达式计算结果为 true 时, 循环终止. 表达式在每次迭代之后被重新计算.</p>
<p><a href="#labels">标签</a>可以用来 &quot;命名&quot; <a href="commands/Continue.htm">Continue</a> 和 <a href="commands/Break.htm">Break</a> 的循环. 这允许脚本轻松地继续或跳出任何数量的嵌套循环而不使用 <a href="commands/Goto.htm">Goto</a>.</p>
<p>内置变量 <strong>A_Index</strong> 包含当前循环迭代的编号. 它在第一次执行循环主体时为 1. 第二次时为 2; 依次类推. 如果一个内部循环被外部循环包围, 则内部循环优先. A_Index 适用于所有类型的循环, 但在循环之外为 0.</p>
<p>对于某些循环类型, 其他内置变量返回有关当前循环项 (注册表键/值, 文件, 子字符串或文本行) 的信息. 这些变量的名称以 <strong>A_Loop</strong> 开头, 如 A_LoopFileName 和 A_LoopReadLine. 它们的值总是对应于最近开始的(但还没有停止) 循环的适应类型. 例如, A_LoopField 返回最里层解析循环中的当前子字符串, 即使它在文件或注册表循环中使用.</p>
<pre>t := &quot;column 1`tcolumn 2`nvalue 1`tvalue 2&quot;
Loop Parse t, "`n"
{
    rowtext := A_LoopField
    rownum := A_Index  <em>; 保存这个用于下面的第二个循环中.</em>
    Loop Parse rowtext, "`t"
    {
        MsgBox rownum ":" A_Index " = " A_LoopField
    }
}
</pre>
<p>循环变量也可以在循环主体外部使用, 例如在循环中调用的函数或子程序中.</p>

<h3 id="not-control-flow">非控制流</h3>
<p>像指令, 标签(包括热键和热字串) 和没有赋值的声明 在脚本从文件加载的时候被处理, 它们不受控制流的制约. 换句话说, 在脚本执行任何控制流程语句之前, 它们将无条件生效. 同样, #If 指令不能影响控制流; 它只是设置代码中指定的任何热键标签和热字串的标准. 每次按下时都会计算热键的条件, 而不是在代码中遇到 #If 指令时.</p>

<h2 id="structure-of-a-script">脚本的结构</h2>

<h3 id="auto-execute-section">自动执行段</h3>
<p>脚本加载完成后, 从顶行开始执行, 直到遇到 <a href="commands/Return.htm">Return</a>, <a href="commands/ExitApp.htm">Exit</a>, 脚本的第一个<a href="Hotkeys.htm">热键/热字串标签</a>, 或脚本的物理结束(无论哪一种). 这个脚本的顶部被称为 <em>自动执行段(部分)</em>, 但它实际上只是程序启动后调用的一个<a href="#subroutines">子程序</a>.</p>
<p class="warning"><strong>注意:</strong> 虽然脚本的 <em>第一个</em> 热键/热字串标签有与 <a href="commands/Return.htm">return</a> 相同的效果, 但是其他热键和标签不会.</p>
<p>自动执行段通常用于配置适用于每个新启动的<a href="misc/Threads.htm">线程</a>的设置. 有关详情, 请参阅<a href="Scripts.htm#auto">脚本顶部</a>.</p>

<h3 id="subroutines">子程序</h3>
<p><em>子程序</em> 是一个可重复使用的代码块, 可以 <em>调用</em> 它来执行一些任务.</p>
<p>脚本使用子程序来定义当按下特定热键或发生其他事件时应该发生什么. 脚本也可以通过使用 <a href="commands/Gosub.htm">Gosub</a> 直接调用子程序.</p>
<p>任何<a href="#labels">标签</a>都可以作为子程序的起点. 子程序没有明确的标记结束点, 而是通过 <a href="commands/Return.htm">Return</a> 或在线程退出时, 将控制权返回给子程序的调用者时作为结束. 例如:</p>
<pre>gosub Label1

Label1:
MsgBox A_ThisLabel
return
</pre>
<p>请注意: 由于标签在正常执行期间到达时没有效果(标签这行就像不存在一样), 因此在此示例中, 对话框将显示两次: 一次在子程序运行时, 一次在子程序返回之后. 一个重要的结果是不能在另一个子程序中定义一个子程序
, 因为内部子程序的 &quot;主体&quot; 会自动执行然后 <em>return</em>, 从而有效地终止外部子程序.</p>
<p>子程序通常应该与任何其他代码块分开定义, 但也可以在<a href="Functions.htm#gosub">函数内定义</a>, 允许子程序访问该函数的静态变量(和局部变量, 但仅在函数运行时).</p>
<p class="warning"><strong>注意:</strong> 函数内定义的子程序在使用局部变量和<a href="#dynamic-variables">动态变量引用</a>方面有一定的限制. 有关详情, 请参阅<a href="Functions.htm#gosub">在函数中使用子程序</a>.
</p>

<h3 id="user-defined-functions">用户自定义函数</h3>
<p>一般来说, <a href="Functions.htm">函数</a>是一种子程序. 但是, 在 AutoHotkey 文档中, &quot;子程序&quot; 通常指的是由标签定义的子程序类型(如上所述).</p>
<p>用户定义的函数与子程序的不同之处在于它们可以 <em>接受参数</em> 并 <em>返回一个值</em>, 并且它们可以具有<a href="Functions.htm#Local">局部变量</a>. 它们可以通过脚本中的<a href="#function-calls">函数调用</a>或程序本身调用, 例如, 如果函数被传递给 <a href="commands/Hotkey.htm">Hotkey</a> 或 <a href="commands/SetTimer.htm">SetTimer</a>.</p>
<p>函数是使用类似于函数调用的语法来定义的, 随后是用大括号括起来的代码块:</p>
<pre>MyFunction(FirstParameter, Second, ByRef Third, Fourth:=&quot;&quot;)
{
    ...
    return &quot;a value&quot;
}
</pre>
<p>和函数调用一样, 函数名和左括号之间不能有空格.</p>
<p>右括号和左大括号之间的换行符是可选的. 两者之间可以有任意数量的空格或注释.</p>
<p><a href="Functions.htm#ByRef">ByRef</a> 表示该参数接受变量引用, 使该参数成为调用者传递的变量的别名. 如果调用者没有传递一个变量, 那么这个参数就像一个普通的局部变量. ByRef 参数也可以是可选的.</p>
<p><a href="Functions.htm#optional">可选</a>参数通过在参数名称后面指定 <code>:=</code> 和一个默认值, 该值必须是加引号的原义字符串, 数字, <code>true</code> 或 <code>false</code>.</p>
<p>函数可以<a href="Functions.htm#return">返回一个值</a>. 如果不是, 则默认返回一个空字符串.</p>
<p>一个函数不能在另一个函数中定义. 另外, 函数定义的位置并不重要; 在脚本中定义的任何函数都可以从其他地方调用.</p>
<p class="note">有关详情, 请参阅<a href="Functions.htm">函数</a>.</p>

<h3 id="-include">#Include</h3>
<p><a href="commands/_Include.htm">#Include</a> 指令使脚本的行为就像指定文件的内容出现在这个确切位置一样. 这通常用于将代码组织到单独的文件中, 或者使用其他用户编写的脚本库.</p>
<p class="warning"><strong>注意:</strong> 以下段落详细说明了一些常见的混淆点.
</p>
<p>使用 #Include 时, 重要的是要考虑文件的内容如果放置在该位置将会产生什么效果, 因为 #Include 将具有相同的效果. 例如:</p>
<ul>
  <li>
<p>#Include 一般不应该在子程序或函数的中间使用.</p>
</li>
  <li>
<p>在脚本的<a href="#auto-execute-section">自动执行段</a>使用 #Include 需要特别的考虑, 因为自动执行段基本上只是一个子程序. 如果子程序的执行会在到达一个 <code>return</code> 时终止, 而不管 <code>return</code> 是在哪个文件中. 同样, 如果文件包含一个热键/热字串, 它可能被认为是脚本的 <em>第一个</em> 热键/热字串, 它将扮演 <code>return</code> 的角色.</p>
</li>
  <li>
<p>脚本只有一个<a href="#auto-execute-section">自动执行段</a>, 而不是每个文件一个.</p>
</li>
</ul>
<p>#Include 可以在<a href="#auto-execute-section">自动执行段</a>安全地使用, 以包含仅包含函数定义的文件, 因为函数定义(但不是函数调用) 在执行期间被跳过. 如果一个文件包含其他代码, 可以通过 <a href="commands/Goto.htm">Goto</a> 跳过文件的内容来避免破坏自动执行段.</p>
<p>与 C/C++ 不同, 如果以前的指令已包含该文件, #Include 不做任何事情. 要多次包含同一文件的内容, 请使用 <a href="commands/_Include.htm">#IncludeAgain</a>.</p>
<p>如果包含函数的脚本文件被保存在一个标准的位置并进行适当的命名, 则它们可以 <em>自动包含</em>, 而不必使用 #Include. 其效果与在主脚本文件末尾使用 #Include 相似. 有关详情, 请参阅<a href="Functions.htm#lib">函数库</a>.</p>

<h2 id="misc">杂项</h2>

<h3 id="dynamic-variables">动态变量</h3>
<p><em>动态变量引用</em> 接受一个文本值, 并将其解释为变量的名称.</p>
<p>动态变量引用的最常见形式称为 <em>双重引用</em> 或 <em>双重解引</em>. 在执行双重引用之前, 目标变量的名称存储在第二个变量中. 然后可以通过使用双重引用将第二个变量间接地将值赋给目标变量. 例如:</p>
<pre>target := 42
second := &quot;target&quot;
MsgBox  second   <em>; 普通(单重) 变量引用 =&gt; target</em>
MsgBox %second%  <em>; 双重解引 =&gt; 42</em>
</pre>
<p>目前, 第二种情况下, <code>second</code> 必须总是包含一个变量名; 任意表达式不被支持.</p>
<p>动态变量引用也可以采用一个或多个文本文本和一个或多个变量的内容, 并将它们组合在一起组成一个单一变量名. 在没有空格的情况下, 这只需简单地按顺序写入名称和百分号括起来的变量. 例如, <code>MyArray%A_Index%</code> 或 <code>MyGrid%X%_%Y%</code>. 这用于访问 <em>伪数组</em>, 如下所示.</p>
<p>These techniques can also be applied to properties and methods of objects. For example:</p>
<pre>clr := {}
for n, component in ["red", "green", "blue"]
    clr.%component% := Random(0, 255)
MsgBox clr.red "," clr.green "," clr.blue</pre>

<h4 id="pseudo-arrays">伪数组</h4>
<p><em>伪数组</em> 实际上只是一堆分开的变量, 但是有一个命名模式, 可以像数组元素一样使用它. 例如:</p>
<pre>
MyArray1 := "A"
MyArray2 := "B"
MyArray3 := "C"
Loop 3
    MsgBox MyArray%A_Index%  <em>; 显示 A, 然后 B, 最后 C.</em>
</pre>
<p>由于单个元素只是普通变量, 所以可以赋值或获取一个值, 但不能 <em>删除</em> 或 <em>插入</em> 元素. 因为伪数组本身并不存在, 所以不能将它传递给函数或从函数返回, 或者作为一个整体进行复制. 由于这些原因, 通常建议在可能的情况下使用<a href="Objects.htm#Usage_Simple_Arrays">普通数组</a>.</p>

<h4 id="associative-pseudo-arrays">关联伪数组</h4>
<p>用于形成最终变量名称的 &quot;index(索引)&quot; 不一定是数字; 它可以是一个字母或关键字, 使伪数组类似于<a href="Objects.htm#Usage_Associative_Arrays">关联数组</a>或<a href="Objects.htm">对象</a>.</p>

<h3 id="labels">标签</h3>
<p>标签标识只是一行代码, 可以用作 <a href="commands/Goto.htm">Goto</a> 目标或形成<a href="#subroutines">子程序</a>. 有三种标签: 普通标签, <a href="Hotkeys.htm">热键</a>标签和<a href="Hotstrings.htm">热字串</a>标签.</p>
<p>普通标签由一个名称后跟一个冒号组成.</p>
<pre>this_is_a_label:
</pre>
<p>热键标签由一个热键后跟双冒号组成.</p>
<pre>^a::
</pre>
<p>热字串标签由一个冒号, 零个或多个<a href="Hotstrings.htm#Options">选项</a>, 另一个冒号, 缩写字符和双冒号组成.</p>
<pre>:*:btw::
</pre>
<p>通常, 除了空格和注释之外, 其他代码不能与标签一起写在同一行上. 然而:</p>
<ul>
  <li>热键标签可以直接后跟着函数调用或其他语句来创建 <em>单行</em> 热键. 换句话说, 如果函数调用, 赋值或表达式与热键标签位于同一行上, 它的行为就好像跟着 <code>return</code> 一样.</li>
  <li>热键和写在双冒号右边的<a href="KeyList.htm">键名</a>实际上是<a href="misc/Remap.htm"><em>重映射</em></a>, 这是<a href="misc/Remap.htm#actually">热键对</a>的快速写法. 例如, <code>a::b</code> 创建热键和标签 <code>*a</code> 和 <code>*a Up</code>, 并不创建名为 <code>a</code> 的标签.</li>
  <li>热字串和写在最后的双冒号的右边的文本是一个 <em>自动替换</em> 热字串. 自动替换热字串不作为标签.</li>
</ul>
<p>有关详情, 请参阅<a href="misc/Labels.htm">标签</a>.</p>

</body>
</html>